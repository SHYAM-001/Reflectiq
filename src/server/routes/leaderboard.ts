// Leaderboard integration API routes following Devvit Web patterns\n// All endpoints must start with /api/ as per Devvit requirements\n\nimport express from 'express';\nimport type { Request, Response } from 'express';\nimport { LeaderboardIntegration } from '../services/LeaderboardIntegration.js';\nimport { context } from '@devvit/web/server';\nimport type {\n  DifficultyLevel,\n  LeaderboardEntry,\n} from '../../shared/types/index.js';\nimport type {\n  LeaderboardStats,\n  PostGameStatistics,\n} from '../services/LeaderboardIntegration.js';\n\n// Initialize leaderboard integration service\nconst leaderboardIntegration = new LeaderboardIntegration();\n\nconst router = express.Router();\n\n// Request/Response type definitions\ninterface GetLeaderboardWithStatsResponse {\n  leaderboard: LeaderboardEntry[];\n  stats: LeaderboardStats;\n  channelName: string;\n  timestamp: string;\n}\n\ninterface GetPostGameStatsRequest {\n  submissionId: string;\n  difficulty: DifficultyLevel;\n  username?: string;\n}\n\ninterface GetPostGameStatsResponse {\n  statistics: PostGameStatistics;\n  timestamp: string;\n}\n\ninterface GetLeaderboardStatsResponse {\n  stats: LeaderboardStats;\n  channelName: string;\n  timestamp: string;\n}\n\ninterface TestRealtimeRequest {\n  difficulty: DifficultyLevel;\n}\n\ninterface TestRealtimeResponse {\n  success: boolean;\n  channelName: string;\n  message: string;\n  timestamp: string;\n}\n\ninterface ErrorResponse {\n  error: {\n    code: string;\n    message: string;\n    details?: any;\n    timestamp: string;\n  };\n}\n\n/**\n * Get leaderboard with real-time statistics\n * GET /api/leaderboard/:difficulty/with-stats\n */\nrouter.get<{ difficulty: DifficultyLevel }, GetLeaderboardWithStatsResponse | ErrorResponse>(\n  '/api/leaderboard/:difficulty/with-stats',\n  async (req: Request<{ difficulty: DifficultyLevel }>, res: Response<GetLeaderboardWithStatsResponse | ErrorResponse>) => {\n    try {\n      const { difficulty } = req.params;\n      const limit = parseInt(req.query.limit as string) || 50;\n      const offset = parseInt(req.query.offset as string) || 0;\n\n      // Validate difficulty level\n      if (!['easy', 'medium', 'hard'].includes(difficulty)) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_DIFFICULTY',\n            message: 'Difficulty must be one of: easy, medium, hard',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Validate pagination parameters\n      if (limit < 1 || limit > 100) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_LIMIT',\n            message: 'Limit must be between 1 and 100',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      if (offset < 0) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_OFFSET',\n            message: 'Offset must be non-negative',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Get leaderboard with statistics\n      const { leaderboard, stats } = await leaderboardIntegration.getLeaderboardWithStats(\n        difficulty,\n        limit,\n        offset\n      );\n\n      // Get real-time channel name for client subscription\n      const channelName = leaderboardIntegration.getChannelName(difficulty);\n\n      const response: GetLeaderboardWithStatsResponse = {\n        leaderboard,\n        stats,\n        channelName,\n        timestamp: new Date().toISOString(),\n      };\n\n      res.status(200).json(response);\n    } catch (error) {\n      console.error('Failed to get leaderboard with stats:', error);\n      res.status(500).json({\n        error: {\n          code: 'LEADERBOARD_STATS_FETCH_FAILED',\n          message: 'Failed to retrieve leaderboard with statistics',\n          details: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString(),\n        },\n      });\n    }\n  }\n);\n\n/**\n * Get leaderboard statistics only\n * GET /api/leaderboard/:difficulty/stats\n */\nrouter.get<{ difficulty: DifficultyLevel }, GetLeaderboardStatsResponse | ErrorResponse>(\n  '/api/leaderboard/:difficulty/stats',\n  async (req: Request<{ difficulty: DifficultyLevel }>, res: Response<GetLeaderboardStatsResponse | ErrorResponse>) => {\n    try {\n      const { difficulty } = req.params;\n\n      // Validate difficulty level\n      if (!['easy', 'medium', 'hard'].includes(difficulty)) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_DIFFICULTY',\n            message: 'Difficulty must be one of: easy, medium, hard',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Get leaderboard statistics\n      const stats = await leaderboardIntegration.getLeaderboardStats(difficulty);\n      \n      // Get real-time channel name\n      const channelName = leaderboardIntegration.getChannelName(difficulty);\n\n      const response: GetLeaderboardStatsResponse = {\n        stats,\n        channelName,\n        timestamp: new Date().toISOString(),\n      };\n\n      res.status(200).json(response);\n    } catch (error) {\n      console.error('Failed to get leaderboard stats:', error);\n      res.status(500).json({\n        error: {\n          code: 'LEADERBOARD_STATS_FAILED',\n          message: 'Failed to retrieve leaderboard statistics',\n          details: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString(),\n        },\n      });\n    }\n  }\n);\n\n/**\n * Get post-game statistics and recommendations\n * POST /api/leaderboard/post-game-stats\n */\nrouter.post<{}, GetPostGameStatsResponse | ErrorResponse, GetPostGameStatsRequest>(\n  '/api/leaderboard/post-game-stats',\n  async (req: Request<{}, GetPostGameStatsResponse | ErrorResponse, GetPostGameStatsRequest>, res: Response<GetPostGameStatsResponse | ErrorResponse>) => {\n    try {\n      const { submissionId, difficulty, username } = req.body;\n\n      // Validate required fields\n      if (!submissionId || !difficulty) {\n        return res.status(400).json({\n          error: {\n            code: 'MISSING_REQUIRED_FIELDS',\n            message: 'submissionId and difficulty are required',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Validate difficulty level\n      if (!['easy', 'medium', 'hard'].includes(difficulty)) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_DIFFICULTY',\n            message: 'Difficulty must be one of: easy, medium, hard',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Get username from context if not provided\n      const playerUsername = username || context.userId || 'anonymous';\n\n      // For this endpoint, we need to reconstruct or retrieve the submission result\n      // In a full implementation, this would be retrieved from Redis using submissionId\n      // For now, we'll create a mock submission result\n      const mockSubmissionResult = {\n        isCorrect: true,\n        correctExit: { row: 7, col: 7, label: 'H8' },\n        playerAnswer: { row: 7, col: 7, label: 'H8' },\n        score: {\n          baseScore: 250,\n          hintMultiplier: 0.8,\n          timeMultiplier: 1.2,\n          finalScore: 240,\n          isCorrect: true,\n        },\n        leaderboardPosition: 15,\n        puzzleHash: 'mock-hash',\n        submissionId,\n        timestamp: new Date(),\n        feedback: {\n          type: 'success' as const,\n          message: 'Great job!',\n        },\n      };\n\n      // Generate post-game statistics\n      const statistics = await leaderboardIntegration.generatePostGameStatistics(\n        mockSubmissionResult,\n        difficulty,\n        playerUsername\n      );\n\n      const response: GetPostGameStatsResponse = {\n        statistics,\n        timestamp: new Date().toISOString(),\n      };\n\n      res.status(200).json(response);\n    } catch (error) {\n      console.error('Failed to get post-game statistics:', error);\n      res.status(500).json({\n        error: {\n          code: 'POST_GAME_STATS_FAILED',\n          message: 'Failed to generate post-game statistics',\n          details: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString(),\n        },\n      });\n    }\n  }\n);\n\n/**\n * Get real-time channel information\n * GET /api/leaderboard/channels\n */\nrouter.get('/api/leaderboard/channels', async (req: Request, res: Response) => {\n  try {\n    const channels = {\n      easy: leaderboardIntegration.getChannelName('easy'),\n      medium: leaderboardIntegration.getChannelName('medium'),\n      hard: leaderboardIntegration.getChannelName('hard'),\n      global: leaderboardIntegration.getGlobalChannelName(),\n    };\n\n    res.status(200).json({\n      channels,\n      description: 'Real-time channels for leaderboard updates',\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Failed to get channel information:', error);\n    res.status(500).json({\n      error: {\n        code: 'CHANNEL_INFO_FAILED',\n        message: 'Failed to retrieve channel information',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n});\n\n/**\n * Test real-time connectivity\n * POST /api/leaderboard/test-realtime\n */\nrouter.post<{}, TestRealtimeResponse | ErrorResponse, TestRealtimeRequest>(\n  '/api/leaderboard/test-realtime',\n  async (req: Request<{}, TestRealtimeResponse | ErrorResponse, TestRealtimeRequest>, res: Response<TestRealtimeResponse | ErrorResponse>) => {\n    try {\n      const { difficulty } = req.body;\n\n      // Validate difficulty level\n      if (!difficulty || !['easy', 'medium', 'hard'].includes(difficulty)) {\n        return res.status(400).json({\n          error: {\n            code: 'INVALID_DIFFICULTY',\n            message: 'Difficulty must be one of: easy, medium, hard',\n            timestamp: new Date().toISOString(),\n          },\n        });\n      }\n\n      // Send test message\n      await leaderboardIntegration.sendTestMessage(difficulty);\n      \n      const channelName = leaderboardIntegration.getChannelName(difficulty);\n\n      const response: TestRealtimeResponse = {\n        success: true,\n        channelName,\n        message: 'Test message sent successfully',\n        timestamp: new Date().toISOString(),\n      };\n\n      res.status(200).json(response);\n    } catch (error) {\n      console.error('Real-time test failed:', error);\n      res.status(500).json({\n        error: {\n          code: 'REALTIME_TEST_FAILED',\n          message: 'Failed to send test message',\n          details: error instanceof Error ? error.message : 'Unknown error',\n          timestamp: new Date().toISOString(),\n        },\n      });\n    }\n  }\n);\n\n/**\n * Get global leaderboard across all difficulties\n * GET /api/leaderboard/global\n */\nrouter.get('/api/leaderboard/global', async (req: Request, res: Response) => {\n  try {\n    const limit = parseInt(req.query.limit as string) || 50;\n    const offset = parseInt(req.query.offset as string) || 0;\n\n    // Validate pagination parameters\n    if (limit < 1 || limit > 100) {\n      return res.status(400).json({\n        error: {\n          code: 'INVALID_LIMIT',\n          message: 'Limit must be between 1 and 100',\n          timestamp: new Date().toISOString(),\n        },\n      });\n    }\n\n    // Get leaderboards for all difficulties\n    const [easyData, mediumData, hardData] = await Promise.all([\n      leaderboardIntegration.getLeaderboardWithStats('easy', Math.ceil(limit / 3), 0),\n      leaderboardIntegration.getLeaderboardWithStats('medium', Math.ceil(limit / 3), 0),\n      leaderboardIntegration.getLeaderboardWithStats('hard', Math.ceil(limit / 3), 0),\n    ]);\n\n    // Combine and sort by score\n    const combinedLeaderboard = [\n      ...easyData.leaderboard,\n      ...mediumData.leaderboard,\n      ...hardData.leaderboard,\n    ]\n      .sort((a, b) => b.finalScore - a.finalScore)\n      .slice(offset, offset + limit);\n\n    // Calculate global statistics\n    const globalStats = {\n      totalPlayers: easyData.stats.totalPlayers + mediumData.stats.totalPlayers + hardData.stats.totalPlayers,\n      difficulties: {\n        easy: easyData.stats,\n        medium: mediumData.stats,\n        hard: hardData.stats,\n      },\n      topScore: Math.max(\n        easyData.stats.topScore,\n        mediumData.stats.topScore,\n        hardData.stats.topScore\n      ),\n      lastUpdated: new Date().toISOString(),\n    };\n\n    const channelName = leaderboardIntegration.getGlobalChannelName();\n\n    res.status(200).json({\n      leaderboard: combinedLeaderboard,\n      stats: globalStats,\n      channelName,\n      timestamp: new Date().toISOString(),\n    });\n  } catch (error) {\n    console.error('Failed to get global leaderboard:', error);\n    res.status(500).json({\n      error: {\n        code: 'GLOBAL_LEADERBOARD_FAILED',\n        message: 'Failed to retrieve global leaderboard',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date().toISOString(),\n      },\n    });\n  }\n});\n\n/**\n * Health check for leaderboard integration service\n * GET /api/leaderboard/health\n */\nrouter.get('/api/leaderboard/health', async (req: Request, res: Response) => {\n  try {\n    // Test basic service functionality\n    const testStats = await leaderboardIntegration.getLeaderboardStats('easy');\n    const isHealthy = testStats && typeof testStats.totalPlayers === 'number';\n\n    res.status(200).json({\n      status: isHealthy ? 'healthy' : 'degraded',\n      timestamp: new Date().toISOString(),\n      version: '1.0.0',\n      services: {\n        leaderboardIntegration: isHealthy ? 'operational' : 'error',\n        realtimeChannels: 'operational', // Assume operational unless we can test\n        statistics: isHealthy ? 'operational' : 'error',\n      },\n      channels: {\n        easy: leaderboardIntegration.getChannelName('easy'),\n        medium: leaderboardIntegration.getChannelName('medium'),\n        hard: leaderboardIntegration.getChannelName('hard'),\n        global: leaderboardIntegration.getGlobalChannelName(),\n      },\n    });\n  } catch (error) {\n    console.error('Leaderboard integration health check failed:', error);\n    res.status(503).json({\n      status: 'unhealthy',\n      timestamp: new Date().toISOString(),\n      error: error instanceof Error ? error.message : 'Unknown error',\n    });\n  }\n});\n\nexport default router;"
