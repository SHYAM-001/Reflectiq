// LeaderboardIntegration service - Real-time leaderboard updates following Devvit Web patterns\n// Handles real-time score updates, rank calculations, and post-game statistics\n\nimport { realtime } from '@devvit/web/server';\nimport { RedisManager } from './RedisManager.js';\nimport type {\n  LeaderboardEntry,\n  DifficultyLevel,\n  SubmissionResult,\n} from '../../shared/types/index.js';\n\nexport interface LeaderboardUpdate {\n  type: 'score_update' | 'rank_change' | 'new_entry';\n  entry: LeaderboardEntry;\n  previousRank?: number;\n  rankChange: number;\n  isPersonalBest: boolean;\n  difficulty: DifficultyLevel;\n  timestamp: string;\n}\n\nexport interface LeaderboardStats {\n  totalPlayers: number;\n  averageScore: number;\n  topScore: number;\n  recentEntries: LeaderboardEntry[];\n  difficulty: DifficultyLevel;\n  lastUpdated: string;\n}\n\nexport interface PostGameStatistics {\n  playerRank: number;\n  totalPlayers: number;\n  scorePercentile: number;\n  difficultyStats: {\n    averageTime: number;\n    averageHints: number;\n    completionRate: number;\n  };\n  achievements: {\n    isPersonalBest: boolean;\n    isTopTen: boolean;\n    isFirstCompletion: boolean;\n    perfectScore: boolean;\n  };\n  recommendations: {\n    nextDifficulty?: DifficultyLevel;\n    improvementTips: string[];\n  };\n}\n\nexport class LeaderboardIntegration {\n  private redisManager: RedisManager;\n  private readonly CHANNEL_PREFIX = 'leaderboard';\n  private readonly STATS_CACHE_TTL = 300; // 5 minutes\n\n  constructor() {\n    this.redisManager = new RedisManager();\n  }\n\n  /**\n   * Update leaderboard and broadcast real-time updates\n   * Called after successful puzzle submission\n   */\n  async updateLeaderboard(submissionResult: SubmissionResult, difficulty: DifficultyLevel, username: string): Promise<void> {\n    try {\n      if (!submissionResult.isCorrect || submissionResult.score.finalScore <= 0) {\n        console.log('Skipping leaderboard update for incorrect/zero-score submission');\n        return;\n      }\n\n      // Get previous rank for comparison\n      const previousRank = await this.redisManager.getUserRank(username, difficulty);\n\n      // Create leaderboard entry\n      const leaderboardEntry: LeaderboardEntry = {\n        rank: submissionResult.leaderboardPosition,\n        username,\n        difficulty,\n        timeElapsed: submissionResult.score.baseScore, // This should be timeElapsed from submission\n        hintsUsed: 0, // This should come from submission data\n        finalScore: submissionResult.score.finalScore,\n        timestamp: submissionResult.timestamp,\n      };\n\n      // Update Redis leaderboard\n      const newRank = await this.redisManager.updateLeaderboard(leaderboardEntry);\n      leaderboardEntry.rank = newRank;\n\n      // Calculate rank change\n      const rankChange = previousRank ? previousRank - newRank : 0;\n      const isPersonalBest = !previousRank || newRank < previousRank;\n\n      // Create update message\n      const updateMessage: LeaderboardUpdate = {\n        type: previousRank ? 'rank_change' : 'new_entry',\n        entry: leaderboardEntry,\n        previousRank,\n        rankChange,\n        isPersonalBest,\n        difficulty,\n        timestamp: new Date().toISOString(),\n      };\n\n      // Broadcast real-time update to all connected clients\n      await this.broadcastLeaderboardUpdate(updateMessage);\n\n      // Update leaderboard statistics cache\n      await this.updateLeaderboardStats(difficulty);\n\n      console.log(`Leaderboard updated: ${username} ranked #${newRank} in ${difficulty} (${rankChange > 0 ? '+' : ''}${rankChange})`);\n    } catch (error) {\n      console.error('Failed to update leaderboard:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Broadcast leaderboard update to all connected clients via realtime\n   */\n  private async broadcastLeaderboardUpdate(update: LeaderboardUpdate): Promise<void> {\n    try {\n      // Send to difficulty-specific channel\n      const difficultyChannel = `${this.CHANNEL_PREFIX}_${update.difficulty}`;\n      await realtime.send(difficultyChannel, update);\n\n      // Send to global leaderboard channel\n      const globalChannel = `${this.CHANNEL_PREFIX}_global`;\n      await realtime.send(globalChannel, update);\n\n      console.log(`Broadcasted leaderboard update to channels: ${difficultyChannel}, ${globalChannel}`);\n    } catch (error) {\n      console.error('Failed to broadcast leaderboard update:', error);\n      // Don't throw - this is for real-time updates only\n    }\n  }\n\n  /**\n   * Get current leaderboard with real-time statistics\n   */\n  async getLeaderboardWithStats(\n    difficulty: DifficultyLevel,\n    limit: number = 50,\n    offset: number = 0\n  ): Promise<{\n    leaderboard: LeaderboardEntry[];\n    stats: LeaderboardStats;\n  }> {\n    try {\n      // Get leaderboard entries\n      const leaderboard = await this.redisManager.getLeaderboard(difficulty, limit, offset);\n\n      // Get or calculate statistics\n      const stats = await this.getLeaderboardStats(difficulty);\n\n      return {\n        leaderboard,\n        stats,\n      };\n    } catch (error) {\n      console.error('Failed to get leaderboard with stats:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get leaderboard statistics for a difficulty level\n   */\n  async getLeaderboardStats(difficulty: DifficultyLevel): Promise<LeaderboardStats> {\n    try {\n      // Try to get cached stats first\n      const cacheKey = `leaderboard_stats:${difficulty}`;\n      const cachedStats = await this.getCachedStats(cacheKey);\n      if (cachedStats) {\n        return cachedStats;\n      }\n\n      // Calculate fresh statistics\n      const leaderboard = await this.redisManager.getLeaderboard(difficulty, 100, 0);\n      \n      const stats: LeaderboardStats = {\n        totalPlayers: leaderboard.length,\n        averageScore: leaderboard.length > 0 \n          ? Math.round(leaderboard.reduce((sum, entry) => sum + entry.finalScore, 0) / leaderboard.length)\n          : 0,\n        topScore: leaderboard.length > 0 ? leaderboard[0].finalScore : 0,\n        recentEntries: leaderboard.slice(0, 5), // Top 5 recent entries\n        difficulty,\n        lastUpdated: new Date().toISOString(),\n      };\n\n      // Cache the statistics\n      await this.cacheStats(cacheKey, stats);\n\n      return stats;\n    } catch (error) {\n      console.error('Failed to get leaderboard stats:', error);\n      return {\n        totalPlayers: 0,\n        averageScore: 0,\n        topScore: 0,\n        recentEntries: [],\n        difficulty,\n        lastUpdated: new Date().toISOString(),\n      };\n    }\n  }\n\n  /**\n   * Generate post-game statistics and recommendations\n   */\n  async generatePostGameStatistics(\n    submissionResult: SubmissionResult,\n    difficulty: DifficultyLevel,\n    username: string\n  ): Promise<PostGameStatistics> {\n    try {\n      const leaderboard = await this.redisManager.getLeaderboard(difficulty, 1000, 0);\n      const playerRank = submissionResult.leaderboardPosition;\n      const totalPlayers = leaderboard.length;\n      \n      // Calculate percentile (higher is better)\n      const scorePercentile = totalPlayers > 0 \n        ? Math.round(((totalPlayers - playerRank + 1) / totalPlayers) * 100)\n        : 100;\n\n      // Calculate difficulty statistics\n      const difficultyStats = this.calculateDifficultyStats(leaderboard);\n\n      // Determine achievements\n      const achievements = {\n        isPersonalBest: submissionResult.leaderboardPosition === 1 || \n                        !await this.redisManager.getUserRank(username, difficulty),\n        isTopTen: playerRank <= 10,\n        isFirstCompletion: totalPlayers === 1,\n        perfectScore: submissionResult.score.hintMultiplier === 1.0 && \n                     submissionResult.score.timeMultiplier >= 1.2,\n      };\n\n      // Generate recommendations\n      const recommendations = this.generateRecommendations(\n        submissionResult,\n        difficulty,\n        achievements,\n        difficultyStats\n      );\n\n      return {\n        playerRank,\n        totalPlayers,\n        scorePercentile,\n        difficultyStats,\n        achievements,\n        recommendations,\n      };\n    } catch (error) {\n      console.error('Failed to generate post-game statistics:', error);\n      // Return minimal stats on error\n      return {\n        playerRank: submissionResult.leaderboardPosition,\n        totalPlayers: 1,\n        scorePercentile: 100,\n        difficultyStats: {\n          averageTime: 0,\n          averageHints: 0,\n          completionRate: 100,\n        },\n        achievements: {\n          isPersonalBest: true,\n          isTopTen: true,\n          isFirstCompletion: true,\n          perfectScore: false,\n        },\n        recommendations: {\n          improvementTips: ['Keep practicing to improve your skills!'],\n        },\n      };\n    }\n  }\n\n  /**\n   * Calculate statistics for a difficulty level\n   */\n  private calculateDifficultyStats(leaderboard: LeaderboardEntry[]): PostGameStatistics['difficultyStats'] {\n    if (leaderboard.length === 0) {\n      return {\n        averageTime: 0,\n        averageHints: 0,\n        completionRate: 0,\n      };\n    }\n\n    const totalTime = leaderboard.reduce((sum, entry) => sum + entry.timeElapsed, 0);\n    const totalHints = leaderboard.reduce((sum, entry) => sum + entry.hintsUsed, 0);\n\n    return {\n      averageTime: Math.round(totalTime / leaderboard.length),\n      averageHints: Math.round((totalHints / leaderboard.length) * 10) / 10, // One decimal place\n      completionRate: 100, // All entries in leaderboard are completions\n    };\n  }\n\n  /**\n   * Generate personalized recommendations based on performance\n   */\n  private generateRecommendations(\n    submissionResult: SubmissionResult,\n    difficulty: DifficultyLevel,\n    achievements: PostGameStatistics['achievements'],\n    difficultyStats: PostGameStatistics['difficultyStats']\n  ): PostGameStatistics['recommendations'] {\n    const tips: string[] = [];\n    let nextDifficulty: DifficultyLevel | undefined;\n\n    // Performance-based tips\n    if (submissionResult.score.hintMultiplier < 1.0) {\n      tips.push('Try solving without hints to maximize your score!');\n    }\n\n    if (submissionResult.score.timeMultiplier < 1.2) {\n      tips.push('Work on solving faster to earn time bonuses.');\n    }\n\n    // Difficulty progression recommendations\n    if (achievements.perfectScore && difficulty === 'easy') {\n      nextDifficulty = 'medium';\n      tips.push('You\\'re ready for medium difficulty puzzles!');\n    } else if (achievements.isTopTen && difficulty === 'medium') {\n      nextDifficulty = 'hard';\n      tips.push('Challenge yourself with hard difficulty!');\n    } else if (submissionResult.leaderboardPosition > 50) {\n      if (difficulty === 'hard') {\n        tips.push('Practice with medium difficulty to build your skills.');\n      } else if (difficulty === 'medium') {\n        tips.push('Master easy puzzles first to understand the mechanics.');\n      }\n    }\n\n    // General tips based on performance\n    if (achievements.isPersonalBest) {\n      tips.push('New personal best! Keep up the great work!');\n    }\n\n    if (tips.length === 0) {\n      tips.push('Keep practicing to improve your puzzle-solving skills!');\n    }\n\n    return {\n      nextDifficulty,\n      improvementTips: tips,\n    };\n  }\n\n  /**\n   * Update cached leaderboard statistics\n   */\n  private async updateLeaderboardStats(difficulty: DifficultyLevel): Promise<void> {\n    try {\n      const cacheKey = `leaderboard_stats:${difficulty}`;\n      \n      // Invalidate cache to force refresh on next request\n      await this.invalidateStatsCache(cacheKey);\n      \n      // Pre-calculate fresh stats\n      await this.getLeaderboardStats(difficulty);\n    } catch (error) {\n      console.error('Failed to update leaderboard stats cache:', error);\n    }\n  }\n\n  /**\n   * Get cached statistics\n   */\n  private async getCachedStats(cacheKey: string): Promise<LeaderboardStats | null> {\n    try {\n      // This would use Redis to get cached stats\n      // For now, return null to always calculate fresh\n      return null;\n    } catch (error) {\n      console.error('Failed to get cached stats:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Cache statistics with TTL\n   */\n  private async cacheStats(cacheKey: string, stats: LeaderboardStats): Promise<void> {\n    try {\n      // This would use Redis to cache stats with TTL\n      // Implementation would store JSON.stringify(stats) with expiration\n      console.log(`Cached stats for key: ${cacheKey}`);\n    } catch (error) {\n      console.error('Failed to cache stats:', error);\n    }\n  }\n\n  /**\n   * Invalidate statistics cache\n   */\n  private async invalidateStatsCache(cacheKey: string): Promise<void> {\n    try {\n      // This would delete the cached stats from Redis\n      console.log(`Invalidated cache for key: ${cacheKey}`);\n    } catch (error) {\n      console.error('Failed to invalidate stats cache:', error);\n    }\n  }\n\n  /**\n   * Get real-time channel name for difficulty\n   */\n  getChannelName(difficulty: DifficultyLevel): string {\n    return `${this.CHANNEL_PREFIX}_${difficulty}`;\n  }\n\n  /**\n   * Get global leaderboard channel name\n   */\n  getGlobalChannelName(): string {\n    return `${this.CHANNEL_PREFIX}_global`;\n  }\n\n  /**\n   * Send test message to verify real-time connectivity\n   */\n  async sendTestMessage(difficulty: DifficultyLevel): Promise<void> {\n    try {\n      const testMessage = {\n        type: 'test',\n        message: 'Real-time connection test',\n        timestamp: new Date().toISOString(),\n      };\n\n      const channelName = this.getChannelName(difficulty);\n      await realtime.send(channelName, testMessage);\n      \n      console.log(`Sent test message to channel: ${channelName}`);\n    } catch (error) {\n      console.error('Failed to send test message:', error);\n      throw error;\n    }\n  }\n}"
