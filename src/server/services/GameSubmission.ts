// GameSubmission service - Answer validation and scoring following Devvit Web patterns\n// Handles in-game submissions, immediate feedback, and leaderboard updates\n\nimport { GameEngine } from './GameEngine.js';\nimport { RedisManager } from './RedisManager.js';\nimport { LeaderboardIntegration } from './LeaderboardIntegration.js';\nimport { context, reddit } from '@devvit/web/server';\nimport type {\n  PuzzleConfiguration,\n  Coordinate,\n  ScoreCalculation,\n  LeaderboardEntry,\n  DifficultyLevel,\n} from '../../shared/types/index.js';\n\nexport interface AnswerSubmission {\n  sessionId: string;\n  puzzleId: string;\n  answer: Coordinate;\n  timeElapsed: number;\n  hintsUsed: number;\n  userId?: string; // Optional, will be derived from context if not provided\n  username?: string; // Optional, will be derived from Reddit API if not provided\n}\n\nexport interface SubmissionResult {\n  isCorrect: boolean;\n  correctExit: Coordinate;\n  playerAnswer: Coordinate;\n  score: ScoreCalculation;\n  leaderboardPosition: number;\n  puzzleHash: string;\n  submissionId: string;\n  timestamp: Date;\n  feedback: {\n    message: string;\n    type: 'success' | 'error' | 'partial';\n    details?: string;\n  };\n}\n\nexport interface SubmissionValidation {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\nexport interface LeaderboardUpdate {\n  previousRank?: number;\n  newRank: number;\n  rankChange: number;\n  isPersonalBest: boolean;\n  totalPlayers: number;\n}\n\nexport class GameSubmission {\n  private gameEngine: GameEngine;\n  private redisManager: RedisManager;\n\n  constructor() {\n    this.gameEngine = new GameEngine();\n    this.redisManager = new RedisManager();\n  }\n\n  /**\n   * Validate answer submission before processing\n   * Ensures all required data is present and valid\n   */\n  validateSubmission(submission: AnswerSubmission): SubmissionValidation {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    // Validate required fields\n    if (!submission.sessionId || submission.sessionId.trim().length === 0) {\n      errors.push('Session ID is required');\n    }\n\n    if (!submission.puzzleId || submission.puzzleId.trim().length === 0) {\n      errors.push('Puzzle ID is required');\n    }\n\n    if (!submission.answer) {\n      errors.push('Answer coordinate is required');\n    } else {\n      // Validate coordinate format\n      if (typeof submission.answer.row !== 'number' || submission.answer.row < 0) {\n        errors.push('Answer row must be a non-negative number');\n      }\n\n      if (typeof submission.answer.col !== 'number' || submission.answer.col < 0) {\n        errors.push('Answer column must be a non-negative number');\n      }\n\n      if (!submission.answer.label || submission.answer.label.trim().length === 0) {\n        errors.push('Answer label is required');\n      }\n    }\n\n    // Validate timing data\n    if (typeof submission.timeElapsed !== 'number' || submission.timeElapsed < 0) {\n      errors.push('Time elapsed must be a non-negative number');\n    }\n\n    if (typeof submission.hintsUsed !== 'number' || submission.hintsUsed < 0 || submission.hintsUsed > 4) {\n      errors.push('Hints used must be between 0 and 4');\n    }\n\n    // Validate timing reasonableness\n    if (submission.timeElapsed > 24 * 60 * 60 * 1000) { // 24 hours\n      warnings.push('Submission time seems unusually long');\n    }\n\n    if (submission.timeElapsed < 1000) { // 1 second\n      warnings.push('Submission time seems unusually fast');\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings,\n    };\n  }\n\n  /**\n   * Process answer submission with complete workflow\n   * Validates answer, calculates score, updates leaderboard\n   */\n  async processSubmission(submission: AnswerSubmission): Promise<SubmissionResult> {\n    try {\n      // Validate submission data\n      const validation = this.validateSubmission(submission);\n      if (!validation.isValid) {\n        throw new Error(`Invalid submission: ${validation.errors.join(', ')}`);\n      }\n\n      // Get user context from Devvit\n      const userId = submission.userId || context.userId || 'anonymous';\n      let username = submission.username;\n      \n      if (!username) {\n        try {\n          username = await reddit.getCurrentUsername() || `user_${userId.slice(-8)}`;\n        } catch (error) {\n          console.warn('Failed to get username from Reddit API:', error);\n          username = `user_${userId.slice(-8)}`;\n        }\n      }\n\n      // Retrieve puzzle configuration\n      const puzzle = await this.redisManager.getPuzzle(submission.puzzleId);\n      if (!puzzle) {\n        throw new Error(`Puzzle not found: ${submission.puzzleId}`);\n      }\n\n      // Validate session exists and is active\n      const session = await this.redisManager.getGameSession(submission.sessionId);\n      if (!session) {\n        throw new Error(`Game session not found: ${submission.sessionId}`);\n      }\n\n      if (!session.isActive) {\n        throw new Error('Game session is no longer active');\n      }\n\n      if (session.puzzleId !== submission.puzzleId) {\n        throw new Error('Session puzzle ID does not match submission');\n      }\n\n      // Validate answer against puzzle solution\n      const isCorrect = this.gameEngine.validateAnswer(puzzle, submission.answer);\n      \n      // Calculate score\n      const score = this.gameEngine.calculateScore(\n        puzzle,\n        isCorrect,\n        submission.timeElapsed,\n        submission.hintsUsed\n      );\n\n      // Generate puzzle hash for verification\n      const puzzleHash = this.gameEngine.generatePuzzleHash(puzzle);\n\n      // Create submission ID\n      const submissionId = `sub_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n      const timestamp = new Date();\n\n      // Update leaderboard if answer is correct\n      let leaderboardPosition = 0;\n      if (isCorrect && score.finalScore > 0) {\n        const leaderboardEntry: LeaderboardEntry = {\n          rank: 0, // Will be set by updateLeaderboard\n          username,\n          difficulty: puzzle.difficulty,\n          timeElapsed: submission.timeElapsed,\n          hintsUsed: submission.hintsUsed,\n          finalScore: score.finalScore,\n          timestamp,\n        };\n\n        leaderboardPosition = await this.redisManager.updateLeaderboard(leaderboardEntry);\n      }\n\n      // Mark session as completed\n      await this.redisManager.updateGameSession(submission.sessionId, {\n        isActive: false,\n      });\n\n      // Generate feedback message\n      const feedback = this.generateFeedback(isCorrect, score, puzzle.difficulty, leaderboardPosition);\n\n      const result: SubmissionResult = {\n        isCorrect,\n        correctExit: puzzle.correctExit!,\n        playerAnswer: submission.answer,\n        score,\n        leaderboardPosition,\n        puzzleHash,\n        submissionId,\n        timestamp,\n        feedback,\n      };\n\n      console.log(`Processed submission ${submissionId} for user ${username}: ${isCorrect ? 'CORRECT' : 'INCORRECT'} (Score: ${score.finalScore})`);\n      \n      return result;\n    } catch (error) {\n      console.error('Failed to process submission:', error);\n      throw new Error(`Submission processing failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Generate user-friendly feedback based on submission result\n   */\n  private generateFeedback(\n    isCorrect: boolean,\n    score: ScoreCalculation,\n    difficulty: DifficultyLevel,\n    leaderboardPosition: number\n  ): SubmissionResult['feedback'] {\n    if (!isCorrect) {\n      return {\n        type: 'error',\n        message: 'Incorrect answer! Try again or use a hint to see the laser path.',\n        details: 'The laser beam exits at a different location. Check your reflection calculations.',\n      };\n    }\n\n    // Correct answer feedback\n    let message = 'üéâ Correct! ';\n    let type: 'success' | 'partial' = 'success';\n    let details = '';\n\n    // Score-based feedback\n    if (score.finalScore === score.baseScore * 1.5) {\n      message += 'Perfect score with excellent time!';\n      details = 'You solved this puzzle with no hints and exceptional speed.';\n    } else if (score.hintMultiplier === 1.0 && score.timeMultiplier > 1.0) {\n      message += 'Great job with no hints used!';\n      details = `You earned a ${score.timeMultiplier}x time bonus.`;\n    } else if (score.hintMultiplier < 1.0) {\n      message += 'Good work!';\n      type = 'partial';\n      const hintsUsed = score.hintMultiplier === 0.8 ? 1 : score.hintMultiplier === 0.6 ? 2 : score.hintMultiplier === 0.4 ? 3 : 4;\n      details = `You used ${hintsUsed} hint${hintsUsed > 1 ? 's' : ''}, which reduced your score multiplier to ${(score.hintMultiplier * 100).toFixed(0)}%.`;\n    } else {\n      message += 'Well done!';\n      details = `You earned ${score.finalScore} points on ${difficulty} difficulty.`;\n    }\n\n    // Leaderboard position feedback\n    if (leaderboardPosition > 0) {\n      if (leaderboardPosition === 1) {\n        message += ' üèÜ You\\'re #1 on the leaderboard!';\n      } else if (leaderboardPosition <= 3) {\n        message += ` ü•â You\\'re #${leaderboardPosition} on the leaderboard!`;\n      } else if (leaderboardPosition <= 10) {\n        message += ` You\\'re #${leaderboardPosition} on the leaderboard!`;\n      } else {\n        details += ` You ranked #${leaderboardPosition} on the leaderboard.`;\n      }\n    }\n\n    return {\n      type,\n      message,\n      details,\n    };\n  }\n\n  /**\n   * Get submission statistics for a user\n   */\n  async getUserSubmissionStats(userId: string): Promise<{\n    totalSubmissions: number;\n    correctSubmissions: number;\n    averageScore: number;\n    bestScore: number;\n    favoritedifficulty: DifficultyLevel;\n    streakCount: number;\n  }> {\n    try {\n      // This would typically query Redis for user submission history\n      // For now, we'll return default values\n      // In a full implementation, this would aggregate data from Redis\n      \n      return {\n        totalSubmissions: 0,\n        correctSubmissions: 0,\n        averageScore: 0,\n        bestScore: 0,\n        favoritedifficulty: 'medium',\n        streakCount: 0,\n      };\n    } catch (error) {\n      console.error('Failed to get user submission stats:', error);\n      return {\n        totalSubmissions: 0,\n        correctSubmissions: 0,\n        averageScore: 0,\n        bestScore: 0,\n        favoritedifficulty: 'medium',\n        streakCount: 0,\n      };\n    }\n  }\n\n  /**\n   * Check if user can submit (rate limiting, cooldown, etc.)\n   */\n  async canUserSubmit(userId: string, puzzleId: string): Promise<{\n    canSubmit: boolean;\n    reason?: string;\n    cooldownRemaining?: number;\n  }> {\n    try {\n      // Check if user has already submitted for this puzzle\n      // This would typically check Redis for existing submissions\n      // For now, we'll allow all submissions\n      \n      return {\n        canSubmit: true,\n      };\n    } catch (error) {\n      console.error('Failed to check submission eligibility:', error);\n      return {\n        canSubmit: false,\n        reason: 'Unable to verify submission eligibility',\n      };\n    }\n  }\n\n  /**\n   * Get leaderboard update information after submission\n   */\n  async getLeaderboardUpdate(\n    username: string,\n    difficulty: DifficultyLevel,\n    newRank: number\n  ): Promise<LeaderboardUpdate> {\n    try {\n      // Get previous rank (this would be stored/cached in a full implementation)\n      const previousRank = await this.redisManager.getUserRank(username, difficulty);\n      \n      // Calculate rank change\n      const rankChange = previousRank ? previousRank - newRank : 0;\n      \n      // Get total players for context\n      const stats = await this.redisManager.getRedisStats();\n      const totalPlayers = stats.leaderboardSizes[difficulty] || 0;\n      \n      // Determine if this is a personal best (simplified logic)\n      const isPersonalBest = !previousRank || newRank < previousRank;\n      \n      return {\n        previousRank,\n        newRank,\n        rankChange,\n        isPersonalBest,\n        totalPlayers,\n      };\n    } catch (error) {\n      console.error('Failed to get leaderboard update:', error);\n      return {\n        newRank,\n        rankChange: 0,\n        isPersonalBest: false,\n        totalPlayers: 0,\n      };\n    }\n  }\n\n  /**\n   * Validate puzzle bounds for answer coordinate\n   */\n  private validateAnswerBounds(answer: Coordinate, puzzle: PuzzleConfiguration): boolean {\n    const gridSize = puzzle.grid.length;\n    \n    return (\n      answer.row >= 0 &&\n      answer.row < gridSize &&\n      answer.col >= 0 &&\n      answer.col < gridSize\n    );\n  }\n\n  /**\n   * Check for suspicious submission patterns (anti-cheat)\n   */\n  private detectSuspiciousActivity(submission: AnswerSubmission): {\n    isSuspicious: boolean;\n    reasons: string[];\n  } {\n    const reasons: string[] = [];\n    \n    // Check for impossibly fast times\n    if (submission.timeElapsed < 5000 && submission.hintsUsed === 0) {\n      reasons.push('Submission time is suspiciously fast');\n    }\n    \n    // Check for impossible hint usage patterns\n    if (submission.hintsUsed > 4) {\n      reasons.push('Invalid number of hints used');\n    }\n    \n    // Additional anti-cheat logic could be added here\n    \n    return {\n      isSuspicious: reasons.length > 0,\n      reasons,\n    };\n  }\n\n  /**\n   * Store submission for audit and analytics\n   */\n  private async storeSubmissionRecord(submission: AnswerSubmission, result: SubmissionResult): Promise<void> {\n    try {\n      // In a full implementation, this would store detailed submission records\n      // for analytics, audit trails, and anti-cheat analysis\n      \n      const submissionRecord = {\n        submissionId: result.submissionId,\n        userId: submission.userId || context.userId,\n        puzzleId: submission.puzzleId,\n        sessionId: submission.sessionId,\n        answer: submission.answer,\n        isCorrect: result.isCorrect,\n        score: result.score.finalScore,\n        timeElapsed: submission.timeElapsed,\n        hintsUsed: submission.hintsUsed,\n        timestamp: result.timestamp.toISOString(),\n        leaderboardPosition: result.leaderboardPosition,\n      };\n      \n      // Store in Redis with expiration\n      const recordKey = `submission_record:${result.submissionId}`;\n      await this.redisManager['redis']?.hSet?.(recordKey, {\n        data: JSON.stringify(submissionRecord),\n      });\n      \n      // Set expiration (30 days)\n      await this.redisManager['redis']?.expire?.(recordKey, 30 * 24 * 60 * 60);\n      \n      console.log(`Stored submission record: ${result.submissionId}`);\n    } catch (error) {\n      console.error('Failed to store submission record:', error);\n      // Don't throw - this is for analytics only\n    }\n  }\n}"
