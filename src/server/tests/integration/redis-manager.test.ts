// Integration tests for RedisManager service following Devvit Web patterns\n// Tests complete data persistence workflows and Redis operations\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { RedisManager, RedisKeyManager } from '../../services/RedisManager.js';\nimport type {\n  PuzzleConfiguration,\n  LeaderboardEntry,\n  DifficultyLevel,\n  UserDailyProgress,\n  DailyPuzzleSet,\n} from '../../../shared/types/index.js';\n\n// Mock Redis for testing\nconst mockRedis = {\n  hSet: vi.fn(),\n  hGetAll: vi.fn(),\n  hGet: vi.fn(),\n  set: vi.fn(),\n  get: vi.fn(),\n  expire: vi.fn(),\n  zAdd: vi.fn(),\n  zRange: vi.fn(),\n  zRank: vi.fn(),\n  zCard: vi.fn(),\n  del: vi.fn(),\n  exists: vi.fn(),\n};\n\n// Mock the redis import\nvi.mock('@devvit/web/server', () => ({\n  redis: mockRedis,\n}));\n\ndescribe('RedisManager Integration Tests', () => {\n  let redisManager: RedisManager;\n  let mockPuzzle: PuzzleConfiguration;\n  let mockLeaderboardEntry: LeaderboardEntry;\n\n  beforeEach(() => {\n    redisManager = new RedisManager();\n    \n    // Reset all mocks\n    vi.clearAllMocks();\n    \n    // Setup mock puzzle\n    mockPuzzle = {\n      id: 'test-puzzle-123',\n      difficulty: 'medium',\n      grid: [\n        [{ material: 'empty', coordinate: { row: 0, col: 0, label: 'A1' }, color: '#ffffff', reflectionBehavior: {} }],\n        [{ material: 'mirror', coordinate: { row: 1, col: 0, label: 'A2' }, color: '#silver', reflectionBehavior: {} }],\n      ],\n      laserEntry: { row: 0, col: 0, label: 'A1' },\n      correctExit: { row: 1, col: 1, label: 'B2' },\n      maxTime: 600000,\n      baseScore: 250,\n    };\n    \n    // Setup mock leaderboard entry\n    mockLeaderboardEntry = {\n      rank: 1,\n      username: 'testuser',\n      difficulty: 'medium',\n      timeElapsed: 120000,\n      hintsUsed: 1,\n      finalScore: 200,\n      timestamp: new Date('2024-01-01T12:00:00Z'),\n    };\n  });\n\n  afterEach(() => {\n    vi.resetAllMocks();\n  });\n\n  describe('Puzzle Storage Workflow', () => {\n    it('should store puzzle configuration correctly', async () => {\n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.storePuzzle(mockPuzzle);\n      \n      const expectedKey = RedisKeyManager.puzzleKey(mockPuzzle.id);\n      \n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        id: mockPuzzle.id,\n        difficulty: mockPuzzle.difficulty,\n        grid: JSON.stringify(mockPuzzle.grid),\n        laserEntry: JSON.stringify(mockPuzzle.laserEntry),\n        correctExit: JSON.stringify(mockPuzzle.correctExit),\n        maxTime: mockPuzzle.maxTime.toString(),\n        baseScore: mockPuzzle.baseScore.toString(),\n        createdAt: expect.any(String),\n      });\n      \n      expect(mockRedis.expire).toHaveBeenCalledWith(expectedKey, 30 * 24 * 60 * 60);\n    });\n\n    it('should retrieve puzzle configuration correctly', async () => {\n      const mockStoredData = {\n        id: mockPuzzle.id,\n        difficulty: mockPuzzle.difficulty,\n        grid: JSON.stringify(mockPuzzle.grid),\n        laserEntry: JSON.stringify(mockPuzzle.laserEntry),\n        correctExit: JSON.stringify(mockPuzzle.correctExit),\n        maxTime: mockPuzzle.maxTime.toString(),\n        baseScore: mockPuzzle.baseScore.toString(),\n      };\n      \n      mockRedis.hGetAll.mockResolvedValue(mockStoredData);\n      \n      const retrievedPuzzle = await redisManager.getPuzzle(mockPuzzle.id);\n      \n      expect(retrievedPuzzle).toBeDefined();\n      expect(retrievedPuzzle!.id).toBe(mockPuzzle.id);\n      expect(retrievedPuzzle!.difficulty).toBe(mockPuzzle.difficulty);\n      expect(retrievedPuzzle!.maxTime).toBe(mockPuzzle.maxTime);\n      expect(retrievedPuzzle!.baseScore).toBe(mockPuzzle.baseScore);\n      \n      const expectedKey = RedisKeyManager.puzzleKey(mockPuzzle.id);\n      expect(mockRedis.hGetAll).toHaveBeenCalledWith(expectedKey);\n    });\n\n    it('should return null for non-existent puzzle', async () => {\n      mockRedis.hGetAll.mockResolvedValue({});\n      \n      const retrievedPuzzle = await redisManager.getPuzzle('non-existent');\n      \n      expect(retrievedPuzzle).toBeNull();\n    });\n\n    it('should handle puzzle storage errors gracefully', async () => {\n      mockRedis.hSet.mockRejectedValue(new Error('Redis connection failed'));\n      \n      await expect(redisManager.storePuzzle(mockPuzzle)).rejects.toThrow('Redis storage failed');\n    });\n  });\n\n  describe('Puzzle Hash Management', () => {\n    it('should store and check puzzle hash uniqueness', async () => {\n      const puzzleHash = 'test-hash-123';\n      \n      mockRedis.set.mockResolvedValue('OK');\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.storePuzzleHash(puzzleHash, mockPuzzle.id);\n      \n      const expectedKey = RedisKeyManager.puzzleHashKey(puzzleHash);\n      expect(mockRedis.set).toHaveBeenCalledWith(expectedKey, mockPuzzle.id);\n      expect(mockRedis.expire).toHaveBeenCalledWith(expectedKey, 365 * 24 * 60 * 60);\n    });\n\n    it('should correctly identify unique puzzle hashes', async () => {\n      mockRedis.get.mockResolvedValue(null);\n      \n      const isUnique = await redisManager.isPuzzleHashUnique('unique-hash');\n      \n      expect(isUnique).toBe(true);\n    });\n\n    it('should correctly identify duplicate puzzle hashes', async () => {\n      mockRedis.get.mockResolvedValue('existing-puzzle-id');\n      \n      const isUnique = await redisManager.isPuzzleHashUnique('duplicate-hash');\n      \n      expect(isUnique).toBe(false);\n    });\n  });\n\n  describe('Leaderboard Management Workflow', () => {\n    it('should update leaderboard with new entry', async () => {\n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.zAdd.mockResolvedValue(1);\n      mockRedis.zRank.mockResolvedValue(0); // First place\n      mockRedis.expire.mockResolvedValue(1);\n      \n      const rank = await redisManager.updateLeaderboard(mockLeaderboardEntry);\n      \n      expect(rank).toBe(1); // 0-based rank + 1\n      \n      const leaderboardKey = RedisKeyManager.leaderboardKey(mockLeaderboardEntry.difficulty);\n      const globalKey = RedisKeyManager.globalLeaderboardKey();\n      \n      expect(mockRedis.zAdd).toHaveBeenCalledWith(leaderboardKey, {\n        member: expect.stringContaining(mockLeaderboardEntry.username),\n        score: mockLeaderboardEntry.finalScore,\n      });\n      \n      expect(mockRedis.zAdd).toHaveBeenCalledWith(globalKey, {\n        member: expect.stringContaining(mockLeaderboardEntry.username),\n        score: mockLeaderboardEntry.finalScore,\n      });\n    });\n\n    it('should retrieve leaderboard entries correctly', async () => {\n      const mockZRangeResult = [\n        { member: 'testuser:2024-01-01T12:00:00.000Z', score: 200 },\n        { member: 'testuser2:2024-01-01T13:00:00.000Z', score: 180 },\n      ];\n      \n      const mockEntryData = {\n        username: 'testuser',\n        difficulty: 'medium',\n        timeElapsed: '120000',\n        hintsUsed: '1',\n        finalScore: '200',\n        timestamp: '2024-01-01T12:00:00.000Z',\n      };\n      \n      mockRedis.zRange.mockResolvedValue(mockZRangeResult);\n      mockRedis.hGetAll.mockResolvedValue(mockEntryData);\n      \n      const leaderboard = await redisManager.getLeaderboard('medium', 10, 0);\n      \n      expect(leaderboard).toHaveLength(2);\n      expect(leaderboard[0].username).toBe('testuser');\n      expect(leaderboard[0].rank).toBe(1);\n      expect(leaderboard[0].finalScore).toBe(200);\n      \n      const leaderboardKey = RedisKeyManager.leaderboardKey('medium');\n      expect(mockRedis.zRange).toHaveBeenCalledWith(\n        leaderboardKey,\n        0,\n        9,\n        { by: 'rank', rev: true }\n      );\n    });\n\n    it('should get user rank correctly', async () => {\n      const mockAllEntries = [\n        { member: 'testuser:2024-01-01T12:00:00.000Z', score: 200 },\n        { member: 'otheruser:2024-01-01T13:00:00.000Z', score: 180 },\n      ];\n      \n      mockRedis.zRange.mockResolvedValue(mockAllEntries);\n      mockRedis.zRank.mockResolvedValue(0);\n      \n      const rank = await redisManager.getUserRank('testuser', 'medium');\n      \n      expect(rank).toBe(1); // 0-based rank + 1\n    });\n\n    it('should return null for user not in leaderboard', async () => {\n      mockRedis.zRange.mockResolvedValue([]);\n      \n      const rank = await redisManager.getUserRank('nonexistent', 'medium');\n      \n      expect(rank).toBeNull();\n    });\n  });\n\n  describe('Game Session Management', () => {\n    it('should create and retrieve game session', async () => {\n      const mockSession = {\n        sessionId: 'session-123',\n        puzzleId: 'puzzle-123',\n        userId: 'user-123',\n        startTime: '2024-01-01T12:00:00Z',\n        difficulty: 'medium' as DifficultyLevel,\n        hintsUsed: [0, 1],\n        isActive: true,\n      };\n      \n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.createGameSession(mockSession);\n      \n      const expectedKey = RedisKeyManager.gameSessionKey(mockSession.sessionId);\n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        sessionId: mockSession.sessionId,\n        puzzleId: mockSession.puzzleId,\n        userId: mockSession.userId,\n        startTime: mockSession.startTime,\n        difficulty: mockSession.difficulty,\n        hintsUsed: JSON.stringify(mockSession.hintsUsed),\n        isActive: mockSession.isActive.toString(),\n      });\n      \n      expect(mockRedis.expire).toHaveBeenCalledWith(expectedKey, 24 * 60 * 60);\n    });\n\n    it('should retrieve game session correctly', async () => {\n      const mockSessionData = {\n        sessionId: 'session-123',\n        puzzleId: 'puzzle-123',\n        userId: 'user-123',\n        startTime: '2024-01-01T12:00:00Z',\n        difficulty: 'medium',\n        hintsUsed: JSON.stringify([0, 1]),\n        isActive: 'true',\n      };\n      \n      mockRedis.hGetAll.mockResolvedValue(mockSessionData);\n      \n      const session = await redisManager.getGameSession('session-123');\n      \n      expect(session).toBeDefined();\n      expect(session!.sessionId).toBe('session-123');\n      expect(session!.difficulty).toBe('medium');\n      expect(session!.hintsUsed).toEqual([0, 1]);\n      expect(session!.isActive).toBe(true);\n    });\n\n    it('should update game session correctly', async () => {\n      mockRedis.hSet.mockResolvedValue(1);\n      \n      await redisManager.updateGameSession('session-123', {\n        hintsUsed: [0, 1, 2],\n        isActive: false,\n      });\n      \n      const expectedKey = RedisKeyManager.gameSessionKey('session-123');\n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        hintsUsed: JSON.stringify([0, 1, 2]),\n        isActive: 'false',\n      });\n    });\n  });\n\n  describe('Hint Usage Tracking', () => {\n    it('should track hint usage correctly', async () => {\n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.trackHintUsage('puzzle-123', 'user-123', 2, 0.6);\n      \n      const expectedKey = RedisKeyManager.hintUsageKey('puzzle-123', 'user-123');\n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        hint_2: expect.stringContaining('\"quadrant\":2'),\n      });\n      \n      expect(mockRedis.expire).toHaveBeenCalledWith(expectedKey, 7 * 24 * 60 * 60);\n    });\n\n    it('should retrieve hint usage correctly', async () => {\n      const mockHintData = {\n        hint_0: JSON.stringify({\n          quadrant: 0,\n          timestamp: '2024-01-01T12:00:00Z',\n          scoreImpact: 0.8,\n        }),\n        hint_2: JSON.stringify({\n          quadrant: 2,\n          timestamp: '2024-01-01T12:05:00Z',\n          scoreImpact: 0.6,\n        }),\n      };\n      \n      mockRedis.hGetAll.mockResolvedValue(mockHintData);\n      \n      const hints = await redisManager.getHintUsage('puzzle-123', 'user-123');\n      \n      expect(hints).toHaveLength(2);\n      expect(hints[0].quadrant).toBe(0);\n      expect(hints[1].quadrant).toBe(2);\n      expect(hints[0].scoreImpact).toBe(0.8);\n      expect(hints[1].scoreImpact).toBe(0.6);\n    });\n  });\n\n  describe('Daily Puzzle Management', () => {\n    it('should store daily puzzle set correctly', async () => {\n      const mockDailySet: DailyPuzzleSet = {\n        date: new Date('2024-01-01'),\n        puzzles: {\n          easy: { ...mockPuzzle, difficulty: 'easy', id: 'easy-123' },\n          medium: { ...mockPuzzle, difficulty: 'medium', id: 'medium-123' },\n          hard: { ...mockPuzzle, difficulty: 'hard', id: 'hard-123' },\n        },\n        postIds: {\n          easy: 'post-easy-123',\n          medium: 'post-medium-123',\n          hard: 'post-hard-123',\n        },\n      };\n      \n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.storeDailyPuzzleSet('2024-01-01', mockDailySet);\n      \n      const expectedKey = RedisKeyManager.dailyPuzzleSetKey('2024-01-01');\n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        date: mockDailySet.date.toISOString(),\n        easyPuzzleId: 'easy-123',\n        mediumPuzzleId: 'medium-123',\n        hardPuzzleId: 'hard-123',\n        easyPostId: 'post-easy-123',\n        mediumPostId: 'post-medium-123',\n        hardPostId: 'post-hard-123',\n      });\n    });\n\n    it('should retrieve daily puzzle set correctly', async () => {\n      const mockDailyData = {\n        date: '2024-01-01T00:00:00.000Z',\n        easyPuzzleId: 'easy-123',\n        mediumPuzzleId: 'medium-123',\n        hardPuzzleId: 'hard-123',\n        easyPostId: 'post-easy-123',\n        mediumPostId: 'post-medium-123',\n        hardPostId: 'post-hard-123',\n      };\n      \n      mockRedis.hGetAll.mockResolvedValue(mockDailyData);\n      \n      // Mock individual puzzle retrievals\n      const mockEasyPuzzle = { ...mockPuzzle, difficulty: 'easy', id: 'easy-123' };\n      const mockMediumPuzzle = { ...mockPuzzle, difficulty: 'medium', id: 'medium-123' };\n      const mockHardPuzzle = { ...mockPuzzle, difficulty: 'hard', id: 'hard-123' };\n      \n      // Setup getPuzzle mock to return different puzzles based on ID\n      const originalGetPuzzle = redisManager.getPuzzle;\n      redisManager.getPuzzle = vi.fn().mockImplementation((id: string) => {\n        if (id === 'easy-123') return Promise.resolve(mockEasyPuzzle);\n        if (id === 'medium-123') return Promise.resolve(mockMediumPuzzle);\n        if (id === 'hard-123') return Promise.resolve(mockHardPuzzle);\n        return Promise.resolve(null);\n      });\n      \n      const dailySet = await redisManager.getDailyPuzzleSet('2024-01-01');\n      \n      expect(dailySet).toBeDefined();\n      expect(dailySet!.puzzles.easy.id).toBe('easy-123');\n      expect(dailySet!.puzzles.medium.id).toBe('medium-123');\n      expect(dailySet!.puzzles.hard.id).toBe('hard-123');\n      expect(dailySet!.postIds.easy).toBe('post-easy-123');\n      \n      // Restore original method\n      redisManager.getPuzzle = originalGetPuzzle;\n    });\n  });\n\n  describe('User Progress Tracking', () => {\n    it('should store user progress correctly', async () => {\n      const mockProgress: UserDailyProgress = {\n        date: new Date('2024-01-01'),\n        completed: {\n          easy: true,\n          medium: false,\n          hard: false,\n        },\n        scores: {\n          easy: 150,\n        },\n      };\n      \n      mockRedis.hSet.mockResolvedValue(1);\n      mockRedis.expire.mockResolvedValue(1);\n      \n      await redisManager.storeUserProgress('user-123', '2024-01-01', mockProgress);\n      \n      const expectedKey = RedisKeyManager.userProgressKey('user-123', '2024-01-01');\n      expect(mockRedis.hSet).toHaveBeenCalledWith(expectedKey, {\n        date: mockProgress.date.toISOString(),\n        completedEasy: 'true',\n        completedMedium: 'false',\n        completedHard: 'false',\n        scoreEasy: '150',\n        scoreMedium: '',\n        scoreHard: '',\n      });\n    });\n\n    it('should retrieve user progress correctly', async () => {\n      const mockProgressData = {\n        date: '2024-01-01T00:00:00.000Z',\n        completedEasy: 'true',\n        completedMedium: 'false',\n        completedHard: 'true',\n        scoreEasy: '150',\n        scoreMedium: '',\n        scoreHard: '400',\n      };\n      \n      mockRedis.hGetAll.mockResolvedValue(mockProgressData);\n      \n      const progress = await redisManager.getUserProgress('user-123', '2024-01-01');\n      \n      expect(progress).toBeDefined();\n      expect(progress!.completed.easy).toBe(true);\n      expect(progress!.completed.medium).toBe(false);\n      expect(progress!.completed.hard).toBe(true);\n      expect(progress!.scores.easy).toBe(150);\n      expect(progress!.scores.medium).toBeUndefined();\n      expect(progress!.scores.hard).toBe(400);\n    });\n\n    it('should return default progress for non-existent user', async () => {\n      mockRedis.hGetAll.mockResolvedValue({});\n      \n      const progress = await redisManager.getUserProgress('new-user', '2024-01-01');\n      \n      expect(progress).toBeDefined();\n      expect(progress!.completed.easy).toBe(false);\n      expect(progress!.completed.medium).toBe(false);\n      expect(progress!.completed.hard).toBe(false);\n      expect(progress!.scores).toEqual({});\n    });\n  });\n\n  describe('Redis Statistics and Monitoring', () => {\n    it('should get Redis statistics correctly', async () => {\n      mockRedis.zCard.mockResolvedValueOnce(25); // easy leaderboard\n      mockRedis.zCard.mockResolvedValueOnce(18); // medium leaderboard\n      mockRedis.zCard.mockResolvedValueOnce(12); // hard leaderboard\n      \n      const stats = await redisManager.getRedisStats();\n      \n      expect(stats.leaderboardSizes.easy).toBe(25);\n      expect(stats.leaderboardSizes.medium).toBe(18);\n      expect(stats.leaderboardSizes.hard).toBe(12);\n      expect(stats.totalPuzzles).toBe(0); // Simplified implementation\n      expect(stats.totalSessions).toBe(0); // Simplified implementation\n    });\n\n    it('should handle Redis statistics errors gracefully', async () => {\n      mockRedis.zCard.mockRejectedValue(new Error('Redis error'));\n      \n      const stats = await redisManager.getRedisStats();\n      \n      expect(stats.leaderboardSizes.easy).toBe(0);\n      expect(stats.leaderboardSizes.medium).toBe(0);\n      expect(stats.leaderboardSizes.hard).toBe(0);\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle Redis connection errors gracefully', async () => {\n      mockRedis.hSet.mockRejectedValue(new Error('Connection timeout'));\n      \n      await expect(redisManager.storePuzzle(mockPuzzle)).rejects.toThrow();\n    });\n\n    it('should handle malformed data gracefully', async () => {\n      mockRedis.hGetAll.mockResolvedValue({\n        id: 'test',\n        grid: 'invalid-json',\n        laserEntry: 'invalid-json',\n      });\n      \n      const puzzle = await redisManager.getPuzzle('test');\n      expect(puzzle).toBeNull();\n    });\n\n    it('should handle empty Redis responses', async () => {\n      mockRedis.hGetAll.mockResolvedValue(null);\n      mockRedis.zRange.mockResolvedValue([]);\n      \n      const puzzle = await redisManager.getPuzzle('empty');\n      const leaderboard = await redisManager.getLeaderboard('easy');\n      \n      expect(puzzle).toBeNull();\n      expect(leaderboard).toEqual([]);\n    });\n  });\n\n  describe('Key Management', () => {\n    it('should generate correct Redis keys', () => {\n      expect(RedisKeyManager.puzzleKey('test-123')).toBe('puzzle:test-123');\n      expect(RedisKeyManager.leaderboardKey('easy')).toBe('leaderboard:easy');\n      expect(RedisKeyManager.userProgressKey('user-123', '2024-01-01')).toBe('user_progress:user-123:2024-01-01');\n      expect(RedisKeyManager.gameSessionKey('session-123')).toBe('session:session-123');\n      expect(RedisKeyManager.hintUsageKey('puzzle-123', 'user-123')).toBe('hints:puzzle-123:user-123');\n    });\n  });\n});"
