// Integration tests for API endpoints following Devvit Web patterns\n// Tests complete request/response workflows and error handling\n\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport request from 'supertest';\nimport express from 'express';\nimport gameRoutes from '../../routes/game.js';\nimport redisRoutes from '../../routes/redis.js';\nimport type {\n  PuzzleConfiguration,\n  DifficultyLevel,\n  LeaderboardEntry,\n} from '../../../shared/types/index.js';\n\n// Mock the services\nvi.mock('../../services/GameEngine.js');\nvi.mock('../../services/RedisManager.js');\nvi.mock('@devvit/web/server', () => ({\n  redis: {\n    hSet: vi.fn(),\n    hGetAll: vi.fn(),\n    zAdd: vi.fn(),\n    zRange: vi.fn(),\n    zRank: vi.fn(),\n    zCard: vi.fn(),\n  },\n}));\n\ndescribe('API Endpoints Integration Tests', () => {\n  let app: express.Application;\n  let mockGameEngine: any;\n  let mockRedisManager: any;\n\n  beforeEach(async () => {\n    // Setup Express app with routes\n    app = express();\n    app.use(express.json());\n    app.use(express.urlencoded({ extended: true }));\n    app.use(gameRoutes);\n    app.use(redisRoutes);\n    \n    // Setup mocks\n    const { GameEngine } = await import('../../services/GameEngine.js');\n    const { RedisManager } = await import('../../services/RedisManager.js');\n    \n    mockGameEngine = {\n      generatePuzzle: vi.fn(),\n      validateAnswer: vi.fn(),\n      calculateScore: vi.fn(),\n      getHintPath: vi.fn(),\n      getDifficultySettings: vi.fn(),\n      getScoringConfig: vi.fn(),\n      generatePuzzleHash: vi.fn(),\n    };\n    \n    mockRedisManager = {\n      getLeaderboard: vi.fn(),\n      getUserRank: vi.fn(),\n      getUserProgress: vi.fn(),\n      getDailyPuzzleSet: vi.fn(),\n      getGameSession: vi.fn(),\n      getHintUsage: vi.fn(),\n      getRedisStats: vi.fn(),\n      cleanupExpiredData: vi.fn(),\n    };\n    \n    // Mock constructors\n    (GameEngine as any).mockImplementation(() => mockGameEngine);\n    (RedisManager as any).mockImplementation(() => mockRedisManager);\n  });\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  describe('Game Engine API Endpoints', () => {\n    describe('POST /api/puzzle/generate', () => {\n      it('should generate puzzle successfully', async () => {\n        const mockPuzzle: PuzzleConfiguration = {\n          id: 'test-puzzle-123',\n          difficulty: 'medium',\n          grid: [],\n          laserEntry: { row: 0, col: 0, label: 'A1' },\n          correctExit: { row: 7, col: 7, label: 'H8' },\n          maxTime: 600000,\n          baseScore: 250,\n        };\n        \n        mockGameEngine.generatePuzzle.mockResolvedValue(mockPuzzle);\n        \n        const response = await request(app)\n          .post('/api/puzzle/generate')\n          .send({ difficulty: 'medium' })\n          .expect(200);\n        \n        expect(response.body.puzzle).toBeDefined();\n        expect(response.body.puzzle.id).toBe('test-puzzle-123');\n        expect(response.body.sessionId).toBeDefined();\n        expect(response.body.startTime).toBeDefined();\n        \n        expect(mockGameEngine.generatePuzzle).toHaveBeenCalledWith('medium');\n      });\n\n      it('should reject invalid difficulty levels', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/generate')\n          .send({ difficulty: 'invalid' })\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_DIFFICULTY');\n        expect(response.body.error.message).toContain('easy, medium, hard');\n      });\n\n      it('should handle puzzle generation failures', async () => {\n        mockGameEngine.generatePuzzle.mockRejectedValue(new Error('Generation failed'));\n        \n        const response = await request(app)\n          .post('/api/puzzle/generate')\n          .send({ difficulty: 'easy' })\n          .expect(500);\n        \n        expect(response.body.error.code).toBe('PUZZLE_GENERATION_FAILED');\n      });\n\n      it('should reject missing difficulty', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/generate')\n          .send({})\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_DIFFICULTY');\n      });\n    });\n\n    describe('POST /api/puzzle/validate', () => {\n      it('should validate correct answer successfully', async () => {\n        mockGameEngine.validateAnswer.mockReturnValue(true);\n        mockGameEngine.calculateScore.mockReturnValue({\n          baseScore: 250,\n          hintMultiplier: 0.8,\n          timeMultiplier: 1.2,\n          finalScore: 240,\n          isCorrect: true,\n        });\n        mockGameEngine.generatePuzzleHash.mockReturnValue('hash-123');\n        \n        const response = await request(app)\n          .post('/api/puzzle/validate')\n          .send({\n            puzzleId: 'puzzle-123',\n            answer: { row: 7, col: 7, label: 'H8' },\n            timeElapsed: 120000,\n            hintsUsed: 1,\n          })\n          .expect(200);\n        \n        expect(response.body.isCorrect).toBe(true);\n        expect(response.body.score.finalScore).toBe(240);\n        expect(response.body.puzzleHash).toBe('hash-123');\n      });\n\n      it('should validate incorrect answer', async () => {\n        mockGameEngine.validateAnswer.mockReturnValue(false);\n        mockGameEngine.calculateScore.mockReturnValue({\n          baseScore: 250,\n          hintMultiplier: 0,\n          timeMultiplier: 0,\n          finalScore: 0,\n          isCorrect: false,\n        });\n        \n        const response = await request(app)\n          .post('/api/puzzle/validate')\n          .send({\n            puzzleId: 'puzzle-123',\n            answer: { row: 0, col: 0, label: 'A1' },\n            timeElapsed: 300000,\n            hintsUsed: 0,\n          })\n          .expect(200);\n        \n        expect(response.body.isCorrect).toBe(false);\n        expect(response.body.score.finalScore).toBe(0);\n      });\n\n      it('should reject invalid request data', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/validate')\n          .send({\n            puzzleId: 'puzzle-123',\n            // Missing answer, timeElapsed, hintsUsed\n          })\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_REQUEST_DATA');\n      });\n\n      it('should reject invalid coordinates', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/validate')\n          .send({\n            puzzleId: 'puzzle-123',\n            answer: { row: 'invalid', col: 'invalid' },\n            timeElapsed: 120000,\n            hintsUsed: 1,\n          })\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_COORDINATE');\n      });\n    });\n\n    describe('POST /api/puzzle/hint', () => {\n      it('should provide hint successfully', async () => {\n        const mockHintPath = [\n          {\n            start: { row: 0, col: 0, label: 'A1' },\n            end: { row: 1, col: 1, label: 'B2' },\n            direction: 'down',\n            material: 'mirror',\n          },\n        ];\n        \n        mockGameEngine.getHintPath.mockReturnValue(mockHintPath);\n        mockGameEngine.getScoringConfig.mockReturnValue({\n          hints: [1.0, 0.8, 0.6, 0.4, 0.2],\n        });\n        \n        const response = await request(app)\n          .post('/api/puzzle/hint')\n          .send({\n            puzzleId: 'puzzle-123',\n            quadrant: 2,\n          })\n          .expect(200);\n        \n        expect(response.body.quadrant).toBe(2);\n        expect(response.body.revealedPath).toEqual(mockHintPath);\n        expect(response.body.scoreMultiplier).toBeDefined();\n      });\n\n      it('should reject invalid quadrant numbers', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/hint')\n          .send({\n            puzzleId: 'puzzle-123',\n            quadrant: 5,\n          })\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_QUADRANT');\n      });\n\n      it('should reject missing request data', async () => {\n        const response = await request(app)\n          .post('/api/puzzle/hint')\n          .send({\n            puzzleId: 'puzzle-123',\n            // Missing quadrant\n          })\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_REQUEST_DATA');\n      });\n    });\n\n    describe('GET /api/game/difficulty/:level', () => {\n      it('should return difficulty settings', async () => {\n        mockGameEngine.getDifficultySettings.mockReturnValue({\n          gridSize: 8,\n          baseScore: 250,\n          maxTime: 600000,\n          materialDensity: 0.4,\n        });\n        \n        const response = await request(app)\n          .get('/api/game/difficulty/medium')\n          .expect(200);\n        \n        expect(response.body.difficulty).toBe('medium');\n        expect(response.body.settings.gridSize).toBe(8);\n        expect(response.body.settings.baseScore).toBe(250);\n      });\n\n      it('should reject invalid difficulty levels', async () => {\n        const response = await request(app)\n          .get('/api/game/difficulty/invalid')\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_DIFFICULTY');\n      });\n    });\n\n    describe('GET /api/game/scoring', () => {\n      it('should return scoring configuration', async () => {\n        mockGameEngine.getScoringConfig.mockReturnValue({\n          hints: [1.0, 0.8, 0.6, 0.4, 0.2],\n          timeBonus: {\n            excellent: 1.5,\n            good: 1.2,\n            average: 1.0,\n          },\n        });\n        \n        const response = await request(app)\n          .get('/api/game/scoring')\n          .expect(200);\n        \n        expect(response.body.scoring.hints).toEqual([1.0, 0.8, 0.6, 0.4, 0.2]);\n        expect(response.body.scoring.timeBonus.excellent).toBe(1.5);\n      });\n    });\n\n    describe('GET /api/game/health', () => {\n      it('should return healthy status', async () => {\n        mockGameEngine.generatePuzzle.mockResolvedValue({\n          id: 'health-test',\n          difficulty: 'easy',\n        });\n        \n        const response = await request(app)\n          .get('/api/game/health')\n          .expect(200);\n        \n        expect(response.body.status).toBe('healthy');\n        expect(response.body.services.gameEngine).toBe('operational');\n      });\n\n      it('should return unhealthy status on error', async () => {\n        mockGameEngine.generatePuzzle.mockRejectedValue(new Error('Service down'));\n        \n        const response = await request(app)\n          .get('/api/game/health')\n          .expect(503);\n        \n        expect(response.body.status).toBe('unhealthy');\n      });\n    });\n  });\n\n  describe('Redis Data Management API Endpoints', () => {\n    describe('GET /api/leaderboard/:difficulty', () => {\n      it('should return leaderboard successfully', async () => {\n        const mockLeaderboard: LeaderboardEntry[] = [\n          {\n            rank: 1,\n            username: 'player1',\n            difficulty: 'medium',\n            timeElapsed: 120000,\n            hintsUsed: 0,\n            finalScore: 300,\n            timestamp: new Date('2024-01-01T12:00:00Z'),\n          },\n          {\n            rank: 2,\n            username: 'player2',\n            difficulty: 'medium',\n            timeElapsed: 150000,\n            hintsUsed: 1,\n            finalScore: 240,\n            timestamp: new Date('2024-01-01T12:05:00Z'),\n          },\n        ];\n        \n        mockRedisManager.getLeaderboard.mockResolvedValue(mockLeaderboard);\n        \n        const response = await request(app)\n          .get('/api/leaderboard/medium')\n          .expect(200);\n        \n        expect(response.body.leaderboard).toHaveLength(2);\n        expect(response.body.leaderboard[0].username).toBe('player1');\n        expect(response.body.difficulty).toBe('medium');\n      });\n\n      it('should handle pagination parameters', async () => {\n        mockRedisManager.getLeaderboard.mockResolvedValue([]);\n        \n        const response = await request(app)\n          .get('/api/leaderboard/easy?limit=10&offset=20')\n          .expect(200);\n        \n        expect(mockRedisManager.getLeaderboard).toHaveBeenCalledWith('easy', 10, 20);\n      });\n\n      it('should reject invalid difficulty', async () => {\n        const response = await request(app)\n          .get('/api/leaderboard/invalid')\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_DIFFICULTY');\n      });\n\n      it('should reject invalid pagination parameters', async () => {\n        const response = await request(app)\n          .get('/api/leaderboard/easy?limit=200')\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_LIMIT');\n      });\n    });\n\n    describe('GET /api/leaderboard/:difficulty/rank/:username', () => {\n      it('should return user rank successfully', async () => {\n        mockRedisManager.getUserRank.mockResolvedValue(5);\n        \n        const response = await request(app)\n          .get('/api/leaderboard/hard/rank/testuser')\n          .expect(200);\n        \n        expect(response.body.username).toBe('testuser');\n        expect(response.body.difficulty).toBe('hard');\n        expect(response.body.rank).toBe(5);\n      });\n\n      it('should handle user not in leaderboard', async () => {\n        mockRedisManager.getUserRank.mockResolvedValue(null);\n        \n        const response = await request(app)\n          .get('/api/leaderboard/medium/rank/newuser')\n          .expect(200);\n        \n        expect(response.body.rank).toBeNull();\n      });\n\n      it('should reject invalid username', async () => {\n        const response = await request(app)\n          .get('/api/leaderboard/easy/rank/')\n          .expect(404); // Express returns 404 for missing route params\n      });\n    });\n\n    describe('GET /api/user/:userId/progress/:date', () => {\n      it('should return user progress successfully', async () => {\n        const mockProgress = {\n          date: new Date('2024-01-01'),\n          completed: {\n            easy: true,\n            medium: false,\n            hard: false,\n          },\n          scores: {\n            easy: 150,\n          },\n        };\n        \n        mockRedisManager.getUserProgress.mockResolvedValue(mockProgress);\n        \n        const response = await request(app)\n          .get('/api/user/user123/progress/2024-01-01')\n          .expect(200);\n        \n        expect(response.body.progress.completed.easy).toBe(true);\n        expect(response.body.progress.scores.easy).toBe(150);\n      });\n\n      it('should reject invalid date format', async () => {\n        const response = await request(app)\n          .get('/api/user/user123/progress/invalid-date')\n          .expect(400);\n        \n        expect(response.body.error.code).toBe('INVALID_DATE_FORMAT');\n      });\n\n      it('should handle progress not found', async () => {\n        mockRedisManager.getUserProgress.mockResolvedValue(null);\n        \n        const response = await request(app)\n          .get('/api/user/user123/progress/2024-01-01')\n          .expect(404);\n        \n        expect(response.body.error.code).toBe('PROGRESS_NOT_FOUND');\n      });\n    });\n\n    describe('GET /api/daily/:date', () => {\n      it('should return daily puzzle set successfully', async () => {\n        const mockDailySet = {\n          date: new Date('2024-01-01'),\n          puzzles: {\n            easy: { id: 'easy-123', difficulty: 'easy' },\n            medium: { id: 'medium-123', difficulty: 'medium' },\n            hard: { id: 'hard-123', difficulty: 'hard' },\n          },\n          postIds: {\n            easy: 'post-easy-123',\n            medium: 'post-medium-123',\n            hard: 'post-hard-123',\n          },\n        };\n        \n        mockRedisManager.getDailyPuzzleSet.mockResolvedValue(mockDailySet);\n        \n        const response = await request(app)\n          .get('/api/daily/2024-01-01')\n          .expect(200);\n        \n        expect(response.body.puzzleSet.puzzles.easy.id).toBe('easy-123');\n        expect(response.body.puzzleSet.postIds.easy).toBe('post-easy-123');\n      });\n\n      it('should handle daily puzzles not found', async () => {\n        mockRedisManager.getDailyPuzzleSet.mockResolvedValue(null);\n        \n        const response = await request(app)\n          .get('/api/daily/2024-01-01')\n          .expect(404);\n        \n        expect(response.body.error.code).toBe('DAILY_PUZZLES_NOT_FOUND');\n      });\n    });\n\n    describe('GET /api/session/:sessionId', () => {\n      it('should return game session successfully', async () => {\n        const mockSession = {\n          sessionId: 'session-123',\n          puzzleId: 'puzzle-123',\n          userId: 'user-123',\n          startTime: '2024-01-01T12:00:00Z',\n          difficulty: 'medium',\n          hintsUsed: [0, 1],\n          isActive: true,\n        };\n        \n        mockRedisManager.getGameSession.mockResolvedValue(mockSession);\n        \n        const response = await request(app)\n          .get('/api/session/session-123')\n          .expect(200);\n        \n        expect(response.body.session.sessionId).toBe('session-123');\n        expect(response.body.session.isActive).toBe(true);\n      });\n\n      it('should handle session not found', async () => {\n        mockRedisManager.getGameSession.mockResolvedValue(null);\n        \n        const response = await request(app)\n          .get('/api/session/nonexistent')\n          .expect(404);\n        \n        expect(response.body.error.code).toBe('SESSION_NOT_FOUND');\n      });\n    });\n\n    describe('GET /api/hints/:puzzleId/:userId', () => {\n      it('should return hint usage successfully', async () => {\n        const mockHints = [\n          {\n            quadrant: 0,\n            timestamp: '2024-01-01T12:00:00Z',\n            scoreImpact: 0.8,\n          },\n          {\n            quadrant: 2,\n            timestamp: '2024-01-01T12:05:00Z',\n            scoreImpact: 0.6,\n          },\n        ];\n        \n        mockRedisManager.getHintUsage.mockResolvedValue(mockHints);\n        \n        const response = await request(app)\n          .get('/api/hints/puzzle-123/user-123')\n          .expect(200);\n        \n        expect(response.body.hints).toHaveLength(2);\n        expect(response.body.totalHints).toBe(2);\n        expect(response.body.hints[0].quadrant).toBe(0);\n      });\n\n      it('should handle empty hint usage', async () => {\n        mockRedisManager.getHintUsage.mockResolvedValue([]);\n        \n        const response = await request(app)\n          .get('/api/hints/puzzle-123/user-123')\n          .expect(200);\n        \n        expect(response.body.hints).toHaveLength(0);\n        expect(response.body.totalHints).toBe(0);\n      });\n    });\n\n    describe('GET /api/redis/stats', () => {\n      it('should return Redis statistics', async () => {\n        const mockStats = {\n          totalPuzzles: 150,\n          totalSessions: 45,\n          leaderboardSizes: {\n            easy: 25,\n            medium: 18,\n            hard: 12,\n          },\n        };\n        \n        mockRedisManager.getRedisStats.mockResolvedValue(mockStats);\n        \n        const response = await request(app)\n          .get('/api/redis/stats')\n          .expect(200);\n        \n        expect(response.body.stats.totalPuzzles).toBe(150);\n        expect(response.body.stats.leaderboardSizes.easy).toBe(25);\n      });\n    });\n\n    describe('POST /api/redis/cleanup', () => {\n      it('should perform cleanup successfully', async () => {\n        mockRedisManager.cleanupExpiredData.mockResolvedValue(undefined);\n        \n        const response = await request(app)\n          .post('/api/redis/cleanup')\n          .expect(200);\n        \n        expect(response.body.status).toBe('success');\n        expect(mockRedisManager.cleanupExpiredData).toHaveBeenCalled();\n      });\n\n      it('should handle cleanup errors', async () => {\n        mockRedisManager.cleanupExpiredData.mockRejectedValue(new Error('Cleanup failed'));\n        \n        const response = await request(app)\n          .post('/api/redis/cleanup')\n          .expect(500);\n        \n        expect(response.body.error.code).toBe('CLEANUP_FAILED');\n      });\n    });\n\n    describe('GET /api/redis/health', () => {\n      it('should return healthy status', async () => {\n        mockRedisManager.getRedisStats.mockResolvedValue({\n          totalPuzzles: 100,\n          totalSessions: 20,\n          leaderboardSizes: { easy: 10, medium: 8, hard: 5 },\n        });\n        \n        const response = await request(app)\n          .get('/api/redis/health')\n          .expect(200);\n        \n        expect(response.body.status).toBe('healthy');\n        expect(response.body.redis).toBe('connected');\n      });\n\n      it('should return unhealthy status on Redis error', async () => {\n        mockRedisManager.getRedisStats.mockRejectedValue(new Error('Redis down'));\n        \n        const response = await request(app)\n          .get('/api/redis/health')\n          .expect(503);\n        \n        expect(response.body.status).toBe('unhealthy');\n        expect(response.body.redis).toBe('disconnected');\n      });\n    });\n  });\n\n  describe('Error Handling and Edge Cases', () => {\n    it('should handle malformed JSON requests', async () => {\n      const response = await request(app)\n        .post('/api/puzzle/generate')\n        .set('Content-Type', 'application/json')\n        .send('invalid json')\n        .expect(400);\n    });\n\n    it('should handle missing Content-Type header', async () => {\n      const response = await request(app)\n        .post('/api/puzzle/generate')\n        .send('difficulty=medium')\n        .expect(200); // Express should handle this gracefully\n    });\n\n    it('should handle very large request payloads', async () => {\n      const largePayload = {\n        difficulty: 'easy',\n        extraData: 'x'.repeat(1000000), // 1MB of data\n      };\n      \n      // This should still work within Devvit's 4MB limit\n      const response = await request(app)\n        .post('/api/puzzle/generate')\n        .send(largePayload);\n      \n      // Response depends on whether the service can handle it\n      expect([200, 413, 500]).toContain(response.status);\n    });\n  });\n\n  describe('Response Format Consistency', () => {\n    it('should return consistent error format across endpoints', async () => {\n      const endpoints = [\n        { method: 'post', path: '/api/puzzle/generate', body: { difficulty: 'invalid' } },\n        { method: 'get', path: '/api/game/difficulty/invalid' },\n        { method: 'get', path: '/api/leaderboard/invalid' },\n      ];\n      \n      for (const endpoint of endpoints) {\n        const request_builder = request(app)[endpoint.method as keyof typeof request](endpoint.path);\n        \n        const response = endpoint.body \n          ? await request_builder.send(endpoint.body).expect(400)\n          : await request_builder.expect(400);\n        \n        expect(response.body.error).toBeDefined();\n        expect(response.body.error.code).toBeDefined();\n        expect(response.body.error.message).toBeDefined();\n        expect(response.body.error.timestamp).toBeDefined();\n      }\n    });\n\n    it('should return consistent success format with timestamps', async () => {\n      mockGameEngine.getDifficultySettings.mockReturnValue({ gridSize: 6 });\n      mockGameEngine.getScoringConfig.mockReturnValue({ hints: [] });\n      mockRedisManager.getRedisStats.mockResolvedValue({ totalPuzzles: 0 });\n      \n      const endpoints = [\n        '/api/game/difficulty/easy',\n        '/api/game/scoring',\n        '/api/redis/stats',\n      ];\n      \n      for (const endpoint of endpoints) {\n        const response = await request(app)\n          .get(endpoint)\n          .expect(200);\n        \n        expect(response.body.timestamp).toBeDefined();\n        expect(new Date(response.body.timestamp)).toBeInstanceOf(Date);\n      }\n    });\n  });\n});"
