// Integration tests for GameEngine service following Devvit Web patterns\n// Tests complete puzzle solving workflows and score calculations\n\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { GameEngine } from '../../services/GameEngine.js';\nimport type {\n  PuzzleConfiguration,\n  DifficultyLevel,\n  Coordinate,\n  ScoreCalculation,\n} from '../../../shared/types/index.js';\n\ndescribe('GameEngine Integration Tests', () => {\n  let gameEngine: GameEngine;\n\n  beforeEach(() => {\n    gameEngine = new GameEngine();\n  });\n\n  afterEach(() => {\n    // Cleanup if needed\n  });\n\n  describe('Puzzle Generation Workflow', () => {\n    it('should generate valid puzzles for all difficulty levels', async () => {\n      const difficulties: DifficultyLevel[] = ['easy', 'medium', 'hard'];\n      \n      for (const difficulty of difficulties) {\n        const puzzle = await gameEngine.generatePuzzle(difficulty);\n        \n        // Validate puzzle structure\n        expect(puzzle).toBeDefined();\n        expect(puzzle.id).toBeTruthy();\n        expect(puzzle.difficulty).toBe(difficulty);\n        expect(puzzle.grid).toBeDefined();\n        expect(puzzle.laserEntry).toBeDefined();\n        expect(puzzle.correctExit).toBeDefined();\n        expect(puzzle.maxTime).toBeGreaterThan(0);\n        expect(puzzle.baseScore).toBeGreaterThan(0);\n        \n        // Validate grid dimensions\n        const expectedSize = difficulty === 'easy' ? 6 : difficulty === 'medium' ? 8 : 10;\n        expect(puzzle.grid.length).toBe(expectedSize);\n        expect(puzzle.grid[0].length).toBe(expectedSize);\n        \n        // Validate laser entry is on grid edge\n        const { row, col } = puzzle.laserEntry;\n        const isOnEdge = row === 0 || row === expectedSize - 1 || col === 0 || col === expectedSize - 1;\n        expect(isOnEdge).toBe(true);\n        \n        // Validate puzzle has solution\n        const laserPath = gameEngine.simulateLaserPath(puzzle.grid, puzzle.laserEntry);\n        expect(laserPath.exitPoint).toBeDefined();\n        expect(laserPath.isComplete).toBe(true);\n        expect(laserPath.segments.length).toBeGreaterThan(0);\n      }\n    }, 30000); // 30 second timeout for puzzle generation\n\n    it('should generate unique puzzles on multiple calls', async () => {\n      const puzzle1 = await gameEngine.generatePuzzle('medium');\n      const puzzle2 = await gameEngine.generatePuzzle('medium');\n      \n      // Puzzles should have different IDs\n      expect(puzzle1.id).not.toBe(puzzle2.id);\n      \n      // Generate hashes to check uniqueness\n      const hash1 = gameEngine.generatePuzzleHash(puzzle1);\n      const hash2 = gameEngine.generatePuzzleHash(puzzle2);\n      expect(hash1).not.toBe(hash2);\n    });\n\n    it('should validate puzzle configuration integrity', async () => {\n      const puzzle = await gameEngine.generatePuzzle('easy');\n      const validation = gameEngine.validatePuzzleConfiguration(puzzle);\n      \n      expect(validation.isValid).toBe(true);\n      expect(validation.errors).toHaveLength(0);\n    });\n  });\n\n  describe('Laser Simulation Workflow', () => {\n    it('should simulate complete laser paths for generated puzzles', async () => {\n      const puzzle = await gameEngine.generatePuzzle('medium');\n      const laserPath = gameEngine.simulateLaserPath(puzzle.grid, puzzle.laserEntry);\n      \n      expect(laserPath).toBeDefined();\n      expect(laserPath.segments).toBeDefined();\n      expect(laserPath.exitPoint).toBeDefined();\n      expect(laserPath.isComplete).toBe(true);\n      \n      // Validate path segments\n      expect(laserPath.segments.length).toBeGreaterThan(0);\n      \n      // First segment should start from laser entry\n      const firstSegment = laserPath.segments[0];\n      expect(firstSegment.start.row).toBe(puzzle.laserEntry.row);\n      expect(firstSegment.start.col).toBe(puzzle.laserEntry.col);\n      \n      // Last segment should end at exit point\n      const lastSegment = laserPath.segments[laserPath.segments.length - 1];\n      expect(lastSegment.end.row).toBe(laserPath.exitPoint!.row);\n      expect(lastSegment.end.col).toBe(laserPath.exitPoint!.col);\n    });\n\n    it('should handle different material interactions correctly', async () => {\n      // Generate multiple puzzles to test various material interactions\n      const puzzles = await Promise.all([\n        gameEngine.generatePuzzle('easy'),\n        gameEngine.generatePuzzle('medium'),\n        gameEngine.generatePuzzle('hard'),\n      ]);\n      \n      for (const puzzle of puzzles) {\n        const laserPath = gameEngine.simulateLaserPath(puzzle.grid, puzzle.laserEntry);\n        \n        // Validate each segment has proper material interaction\n        for (const segment of laserPath.segments) {\n          expect(segment.material).toBeDefined();\n          expect(['mirror', 'water', 'glass', 'metal', 'absorber', 'empty']).toContain(segment.material);\n          expect(segment.direction).toBeDefined();\n          expect(['up', 'down', 'left', 'right']).toContain(segment.direction);\n        }\n      }\n    });\n  });\n\n  describe('Hint System Workflow', () => {\n    it('should provide valid hints for all quadrants', async () => {\n      const puzzle = await gameEngine.generatePuzzle('medium');\n      \n      for (let quadrant = 0; quadrant < 4; quadrant++) {\n        const hintPath = gameEngine.getHintPath(puzzle, quadrant);\n        \n        expect(Array.isArray(hintPath)).toBe(true);\n        \n        // Validate hint path segments are within quadrant bounds\n        const gridSize = puzzle.grid.length;\n        const halfSize = Math.floor(gridSize / 2);\n        \n        const quadrantBounds = {\n          0: { minRow: 0, maxRow: halfSize, minCol: 0, maxCol: halfSize },\n          1: { minRow: 0, maxRow: halfSize, minCol: halfSize, maxCol: gridSize },\n          2: { minRow: halfSize, maxRow: gridSize, minCol: 0, maxCol: halfSize },\n          3: { minRow: halfSize, maxRow: gridSize, minCol: halfSize, maxCol: gridSize },\n        };\n        \n        const bounds = quadrantBounds[quadrant as keyof typeof quadrantBounds];\n        \n        for (const segment of hintPath) {\n          const startInQuadrant = \n            segment.start.row >= bounds.minRow && segment.start.row < bounds.maxRow &&\n            segment.start.col >= bounds.minCol && segment.start.col < bounds.maxCol;\n          \n          const endInQuadrant = \n            segment.end.row >= bounds.minRow && segment.end.row < bounds.maxRow &&\n            segment.end.col >= bounds.minCol && segment.end.col < bounds.maxCol;\n          \n          // At least one end of the segment should be in the quadrant\n          expect(startInQuadrant || endInQuadrant).toBe(true);\n        }\n      }\n    });\n\n    it('should handle invalid quadrant numbers gracefully', async () => {\n      const puzzle = await gameEngine.generatePuzzle('easy');\n      \n      expect(() => gameEngine.getHintPath(puzzle, -1)).toThrow();\n      expect(() => gameEngine.getHintPath(puzzle, 4)).toThrow();\n      expect(() => gameEngine.getHintPath(puzzle, 999)).toThrow();\n    });\n  });\n\n  describe('Answer Validation Workflow', () => {\n    it('should correctly validate correct answers', async () => {\n      const puzzle = await gameEngine.generatePuzzle('medium');\n      \n      // Test with correct answer\n      const isCorrect = gameEngine.validateAnswer(puzzle, puzzle.correctExit!);\n      expect(isCorrect).toBe(true);\n    });\n\n    it('should correctly reject incorrect answers', async () => {\n      const puzzle = await gameEngine.generatePuzzle('medium');\n      \n      // Test with incorrect answers\n      const incorrectAnswers: Coordinate[] = [\n        { row: 0, col: 0, label: 'A1' },\n        { row: puzzle.grid.length - 1, col: puzzle.grid.length - 1, label: 'Z9' },\n        { row: Math.floor(puzzle.grid.length / 2), col: Math.floor(puzzle.grid.length / 2), label: 'D4' },\n      ];\n      \n      for (const incorrectAnswer of incorrectAnswers) {\n        // Skip if this happens to be the correct answer\n        if (incorrectAnswer.row === puzzle.correctExit!.row && \n            incorrectAnswer.col === puzzle.correctExit!.col) {\n          continue;\n        }\n        \n        const isCorrect = gameEngine.validateAnswer(puzzle, incorrectAnswer);\n        expect(isCorrect).toBe(false);\n      }\n    });\n  });\n\n  describe('Score Calculation Workflow', () => {\n    it('should calculate correct scores for various scenarios', async () => {\n      const puzzle = await gameEngine.generatePuzzle('medium');\n      \n      // Test correct answer with no hints, fast time\n      const fastTime = Math.floor(puzzle.maxTime * 0.2); // 20% of max time\n      const scoreNoHints = gameEngine.calculateScore(puzzle, true, fastTime, 0);\n      \n      expect(scoreNoHints.isCorrect).toBe(true);\n      expect(scoreNoHints.finalScore).toBeGreaterThan(puzzle.baseScore);\n      expect(scoreNoHints.hintMultiplier).toBe(1.0);\n      expect(scoreNoHints.timeMultiplier).toBe(1.5); // Excellent time bonus\n      \n      // Test correct answer with hints, slow time\n      const slowTime = Math.floor(puzzle.maxTime * 0.8); // 80% of max time\n      const scoreWithHints = gameEngine.calculateScore(puzzle, true, slowTime, 2);\n      \n      expect(scoreWithHints.isCorrect).toBe(true);\n      expect(scoreWithHints.finalScore).toBeLessThan(puzzle.baseScore);\n      expect(scoreWithHints.hintMultiplier).toBe(0.6); // 2 hints used\n      expect(scoreWithHints.timeMultiplier).toBe(1.0); // Average time\n      \n      // Test incorrect answer\n      const scoreIncorrect = gameEngine.calculateScore(puzzle, false, fastTime, 0);\n      \n      expect(scoreIncorrect.isCorrect).toBe(false);\n      expect(scoreIncorrect.finalScore).toBe(0);\n      expect(scoreIncorrect.hintMultiplier).toBe(0);\n      expect(scoreIncorrect.timeMultiplier).toBe(0);\n    });\n\n    it('should apply correct multipliers for different hint counts', async () => {\n      const puzzle = await gameEngine.generatePuzzle('easy');\n      const mediumTime = Math.floor(puzzle.maxTime * 0.5);\n      \n      const expectedMultipliers = [1.0, 0.8, 0.6, 0.4, 0.2];\n      \n      for (let hints = 0; hints <= 4; hints++) {\n        const score = gameEngine.calculateScore(puzzle, true, mediumTime, hints);\n        expect(score.hintMultiplier).toBe(expectedMultipliers[hints]);\n      }\n    });\n\n    it('should apply correct time bonuses', async () => {\n      const puzzle = await gameEngine.generatePuzzle('hard');\n      \n      // Excellent time (under 25%)\n      const excellentTime = Math.floor(puzzle.maxTime * 0.2);\n      const excellentScore = gameEngine.calculateScore(puzzle, true, excellentTime, 0);\n      expect(excellentScore.timeMultiplier).toBe(1.5);\n      \n      // Good time (under 50%)\n      const goodTime = Math.floor(puzzle.maxTime * 0.4);\n      const goodScore = gameEngine.calculateScore(puzzle, true, goodTime, 0);\n      expect(goodScore.timeMultiplier).toBe(1.2);\n      \n      // Average time (over 50%)\n      const averageTime = Math.floor(puzzle.maxTime * 0.7);\n      const averageScore = gameEngine.calculateScore(puzzle, true, averageTime, 0);\n      expect(averageScore.timeMultiplier).toBe(1.0);\n    });\n  });\n\n  describe('Puzzle Hash Generation', () => {\n    it('should generate consistent hashes for identical puzzles', async () => {\n      const puzzle = await gameEngine.generatePuzzle('easy');\n      \n      const hash1 = gameEngine.generatePuzzleHash(puzzle);\n      const hash2 = gameEngine.generatePuzzleHash(puzzle);\n      \n      expect(hash1).toBe(hash2);\n      expect(hash1).toBeTruthy();\n      expect(typeof hash1).toBe('string');\n    });\n\n    it('should generate different hashes for different puzzles', async () => {\n      const puzzle1 = await gameEngine.generatePuzzle('easy');\n      const puzzle2 = await gameEngine.generatePuzzle('easy');\n      \n      const hash1 = gameEngine.generatePuzzleHash(puzzle1);\n      const hash2 = gameEngine.generatePuzzleHash(puzzle2);\n      \n      expect(hash1).not.toBe(hash2);\n    });\n  });\n\n  describe('Configuration and Settings', () => {\n    it('should return correct difficulty settings', () => {\n      const easySettings = gameEngine.getDifficultySettings('easy');\n      expect(easySettings.gridSize).toBe(6);\n      expect(easySettings.baseScore).toBe(100);\n      expect(easySettings.maxTime).toBe(300000);\n      \n      const mediumSettings = gameEngine.getDifficultySettings('medium');\n      expect(mediumSettings.gridSize).toBe(8);\n      expect(mediumSettings.baseScore).toBe(250);\n      expect(mediumSettings.maxTime).toBe(600000);\n      \n      const hardSettings = gameEngine.getDifficultySettings('hard');\n      expect(hardSettings.gridSize).toBe(10);\n      expect(hardSettings.baseScore).toBe(500);\n      expect(hardSettings.maxTime).toBe(900000);\n    });\n\n    it('should return correct scoring configuration', () => {\n      const scoringConfig = gameEngine.getScoringConfig();\n      \n      expect(scoringConfig.hints).toEqual([1.0, 0.8, 0.6, 0.4, 0.2]);\n      expect(scoringConfig.timeBonus.excellent).toBe(1.5);\n      expect(scoringConfig.timeBonus.good).toBe(1.2);\n      expect(scoringConfig.timeBonus.average).toBe(1.0);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle invalid puzzle configurations gracefully', () => {\n      const invalidPuzzle: PuzzleConfiguration = {\n        id: 'invalid',\n        difficulty: 'easy',\n        grid: [], // Invalid empty grid\n        laserEntry: { row: -1, col: -1, label: 'Invalid' }, // Invalid coordinates\n        correctExit: { row: 999, col: 999, label: 'Invalid' }, // Invalid coordinates\n        maxTime: 0,\n        baseScore: 0,\n      };\n      \n      const validation = gameEngine.validatePuzzleConfiguration(invalidPuzzle);\n      expect(validation.isValid).toBe(false);\n      expect(validation.errors.length).toBeGreaterThan(0);\n    });\n\n    it('should handle laser simulation errors gracefully', () => {\n      const invalidGrid: any[][] = [];\n      const invalidEntry: Coordinate = { row: 0, col: 0, label: 'A1' };\n      \n      const result = gameEngine.simulateLaserPath(invalidGrid, invalidEntry);\n      expect(result.isComplete).toBe(false);\n      expect(result.exitPoint).toBeNull();\n      expect(result.segments).toEqual([]);\n    });\n  });\n\n  describe('Performance Tests', () => {\n    it('should generate puzzles within reasonable time limits', async () => {\n      const startTime = Date.now();\n      \n      const puzzle = await gameEngine.generatePuzzle('medium');\n      \n      const endTime = Date.now();\n      const generationTime = endTime - startTime;\n      \n      // Should generate puzzle within 10 seconds\n      expect(generationTime).toBeLessThan(10000);\n      expect(puzzle).toBeDefined();\n    });\n\n    it('should handle multiple concurrent puzzle generations', async () => {\n      const startTime = Date.now();\n      \n      const puzzlePromises = Array.from({ length: 5 }, () => \n        gameEngine.generatePuzzle('easy')\n      );\n      \n      const puzzles = await Promise.all(puzzlePromises);\n      \n      const endTime = Date.now();\n      const totalTime = endTime - startTime;\n      \n      // All puzzles should be generated\n      expect(puzzles).toHaveLength(5);\n      puzzles.forEach(puzzle => {\n        expect(puzzle).toBeDefined();\n        expect(puzzle.id).toBeTruthy();\n      });\n      \n      // Should complete within 30 seconds (Devvit serverless limit)\n      expect(totalTime).toBeLessThan(30000);\n    });\n  });\n});"
