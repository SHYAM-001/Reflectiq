// Real-time leaderboard hook following Devvit Web patterns\n// Handles real-time updates using Devvit's connectRealtime API\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { connectRealtime } from '@devvit/web/client';\nimport type {\n  LeaderboardEntry,\n  DifficultyLevel,\n} from '../../shared/types/index.js';\n\nexport interface LeaderboardUpdate {\n  type: 'score_update' | 'rank_change' | 'new_entry';\n  entry: LeaderboardEntry;\n  previousRank?: number;\n  rankChange: number;\n  isPersonalBest: boolean;\n  difficulty: DifficultyLevel;\n  timestamp: string;\n}\n\nexport interface LeaderboardStats {\n  totalPlayers: number;\n  averageScore: number;\n  topScore: number;\n  recentEntries: LeaderboardEntry[];\n  difficulty: DifficultyLevel;\n  lastUpdated: string;\n}\n\nexport interface UseRealtimeLeaderboardOptions {\n  difficulty: DifficultyLevel;\n  initialLeaderboard?: LeaderboardEntry[];\n  initialStats?: LeaderboardStats;\n  maxEntries?: number;\n  onUpdate?: (update: LeaderboardUpdate) => void;\n  onConnect?: () => void;\n  onDisconnect?: () => void;\n  onError?: (error: Error) => void;\n}\n\nexport interface UseRealtimeLeaderboardReturn {\n  leaderboard: LeaderboardEntry[];\n  stats: LeaderboardStats | null;\n  isConnected: boolean;\n  isLoading: boolean;\n  error: string | null;\n  reconnect: () => Promise<void>;\n  disconnect: () => Promise<void>;\n  refreshLeaderboard: () => Promise<void>;\n}\n\n/**\n * Custom hook for real-time leaderboard updates\n * Follows Devvit Web patterns for realtime connectivity\n */\nexport function useRealtimeLeaderboard({\n  difficulty,\n  initialLeaderboard = [],\n  initialStats = null,\n  maxEntries = 50,\n  onUpdate,\n  onConnect,\n  onDisconnect,\n  onError,\n}: UseRealtimeLeaderboardOptions): UseRealtimeLeaderboardReturn {\n  const [leaderboard, setLeaderboard] = useState<LeaderboardEntry[]>(initialLeaderboard);\n  const [stats, setStats] = useState<LeaderboardStats | null>(initialStats);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const connectionRef = useRef<any>(null);\n  const channelNameRef = useRef<string>(`leaderboard_${difficulty}`);\n\n  /**\n   * Handle incoming real-time messages\n   */\n  const handleMessage = useCallback((data: LeaderboardUpdate) => {\n    try {\n      console.log('Received leaderboard update:', data);\n      \n      // Update leaderboard based on message type\n      setLeaderboard(prevLeaderboard => {\n        let updatedLeaderboard = [...prevLeaderboard];\n        \n        switch (data.type) {\n          case 'new_entry':\n            // Add new entry and re-sort\n            updatedLeaderboard.push(data.entry);\n            break;\n            \n          case 'rank_change':\n          case 'score_update':\n            // Update existing entry or add if not found\n            const existingIndex = updatedLeaderboard.findIndex(\n              entry => entry.username === data.entry.username\n            );\n            \n            if (existingIndex >= 0) {\n              updatedLeaderboard[existingIndex] = data.entry;\n            } else {\n              updatedLeaderboard.push(data.entry);\n            }\n            break;\n        }\n        \n        // Sort by score (descending) and limit entries\n        updatedLeaderboard = updatedLeaderboard\n          .sort((a, b) => b.finalScore - a.finalScore)\n          .slice(0, maxEntries)\n          .map((entry, index) => ({ ...entry, rank: index + 1 }));\n        \n        return updatedLeaderboard;\n      });\n      \n      // Update statistics if provided\n      if (data.type === 'new_entry' || data.type === 'score_update') {\n        setStats(prevStats => {\n          if (!prevStats) return prevStats;\n          \n          return {\n            ...prevStats,\n            totalPlayers: prevStats.totalPlayers + (data.type === 'new_entry' ? 1 : 0),\n            topScore: Math.max(prevStats.topScore, data.entry.finalScore),\n            lastUpdated: data.timestamp,\n          };\n        });\n      }\n      \n      // Call update callback\n      if (onUpdate) {\n        onUpdate(data);\n      }\n      \n      setError(null);\n    } catch (err) {\n      console.error('Error handling leaderboard message:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to process leaderboard update';\n      setError(errorMessage);\n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [maxEntries, onUpdate, onError]);\n\n  /**\n   * Connect to real-time channel\n   */\n  const connect = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      // Disconnect existing connection\n      if (connectionRef.current) {\n        await connectionRef.current.disconnect();\n      }\n      \n      const channelName = `leaderboard_${difficulty}`;\n      channelNameRef.current = channelName;\n      \n      console.log(`Connecting to leaderboard channel: ${channelName}`);\n      \n      // Connect using Devvit Web realtime API\n      const connection = await connectRealtime({\n        channel: channelName,\n        onConnect: (channel) => {\n          console.log(`Connected to leaderboard channel: ${channel}`);\n          setIsConnected(true);\n          setIsLoading(false);\n          if (onConnect) {\n            onConnect();\n          }\n        },\n        onDisconnect: (channel) => {\n          console.log(`Disconnected from leaderboard channel: ${channel}`);\n          setIsConnected(false);\n          if (onDisconnect) {\n            onDisconnect();\n          }\n        },\n        onMessage: handleMessage,\n      });\n      \n      connectionRef.current = connection;\n    } catch (err) {\n      console.error('Failed to connect to leaderboard channel:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to connect to real-time updates';\n      setError(errorMessage);\n      setIsLoading(false);\n      setIsConnected(false);\n      \n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [difficulty, handleMessage, onConnect, onDisconnect, onError]);\n\n  /**\n   * Disconnect from real-time channel\n   */\n  const disconnect = useCallback(async () => {\n    try {\n      if (connectionRef.current) {\n        await connectionRef.current.disconnect();\n        connectionRef.current = null;\n      }\n      setIsConnected(false);\n    } catch (err) {\n      console.error('Failed to disconnect from leaderboard channel:', err);\n    }\n  }, []);\n\n  /**\n   * Reconnect to real-time channel\n   */\n  const reconnect = useCallback(async () => {\n    await disconnect();\n    await connect();\n  }, [connect, disconnect]);\n\n  /**\n   * Refresh leaderboard data from API\n   */\n  const refreshLeaderboard = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const response = await fetch(`/api/leaderboard/${difficulty}/with-stats`);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch leaderboard: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      setLeaderboard(data.leaderboard || []);\n      setStats(data.stats || null);\n      setIsLoading(false);\n    } catch (err) {\n      console.error('Failed to refresh leaderboard:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to refresh leaderboard';\n      setError(errorMessage);\n      setIsLoading(false);\n      \n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [difficulty, onError]);\n\n  /**\n   * Initialize connection on mount and difficulty change\n   */\n  useEffect(() => {\n    connect();\n    \n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [difficulty]); // Re-connect when difficulty changes\n\n  /**\n   * Handle visibility change to reconnect when tab becomes visible\n   */\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && !isConnected && !isLoading) {\n        console.log('Tab became visible, reconnecting to leaderboard...');\n        reconnect();\n      }\n    };\n    \n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    \n    return () => {\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }, [isConnected, isLoading, reconnect]);\n\n  /**\n   * Auto-refresh leaderboard data periodically as fallback\n   */\n  useEffect(() => {\n    // Refresh every 5 minutes as fallback\n    const interval = setInterval(() => {\n      if (!isConnected) {\n        console.log('Not connected to real-time, refreshing leaderboard...');\n        refreshLeaderboard();\n      }\n    }, 5 * 60 * 1000);\n    \n    return () => clearInterval(interval);\n  }, [isConnected, refreshLeaderboard]);\n\n  return {\n    leaderboard,\n    stats,\n    isConnected,\n    isLoading,\n    error,\n    reconnect,\n    disconnect,\n    refreshLeaderboard,\n  };\n}\n\n/**\n * Hook for global leaderboard across all difficulties\n */\nexport function useGlobalRealtimeLeaderboard({\n  initialLeaderboard = [],\n  maxEntries = 50,\n  onUpdate,\n  onConnect,\n  onDisconnect,\n  onError,\n}: Omit<UseRealtimeLeaderboardOptions, 'difficulty' | 'initialStats'> & {\n  initialLeaderboard?: LeaderboardEntry[];\n}): Omit<UseRealtimeLeaderboardReturn, 'stats'> {\n  const [leaderboard, setLeaderboard] = useState<LeaderboardEntry[]>(initialLeaderboard);\n  const [isConnected, setIsConnected] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  \n  const connectionRef = useRef<any>(null);\n\n  const handleMessage = useCallback((data: LeaderboardUpdate) => {\n    try {\n      console.log('Received global leaderboard update:', data);\n      \n      setLeaderboard(prevLeaderboard => {\n        let updatedLeaderboard = [...prevLeaderboard];\n        \n        // Update or add entry\n        const existingIndex = updatedLeaderboard.findIndex(\n          entry => entry.username === data.entry.username && entry.difficulty === data.entry.difficulty\n        );\n        \n        if (existingIndex >= 0) {\n          updatedLeaderboard[existingIndex] = data.entry;\n        } else {\n          updatedLeaderboard.push(data.entry);\n        }\n        \n        // Sort by score and limit entries\n        return updatedLeaderboard\n          .sort((a, b) => b.finalScore - a.finalScore)\n          .slice(0, maxEntries)\n          .map((entry, index) => ({ ...entry, rank: index + 1 }));\n      });\n      \n      if (onUpdate) {\n        onUpdate(data);\n      }\n      \n      setError(null);\n    } catch (err) {\n      console.error('Error handling global leaderboard message:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to process global leaderboard update';\n      setError(errorMessage);\n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [maxEntries, onUpdate, onError]);\n\n  const connect = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      if (connectionRef.current) {\n        await connectionRef.current.disconnect();\n      }\n      \n      const channelName = 'leaderboard_global';\n      \n      const connection = await connectRealtime({\n        channel: channelName,\n        onConnect: () => {\n          setIsConnected(true);\n          setIsLoading(false);\n          if (onConnect) onConnect();\n        },\n        onDisconnect: () => {\n          setIsConnected(false);\n          if (onDisconnect) onDisconnect();\n        },\n        onMessage: handleMessage,\n      });\n      \n      connectionRef.current = connection;\n    } catch (err) {\n      console.error('Failed to connect to global leaderboard channel:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to connect to global updates';\n      setError(errorMessage);\n      setIsLoading(false);\n      setIsConnected(false);\n      \n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [handleMessage, onConnect, onDisconnect, onError]);\n\n  const disconnect = useCallback(async () => {\n    try {\n      if (connectionRef.current) {\n        await connectionRef.current.disconnect();\n        connectionRef.current = null;\n      }\n      setIsConnected(false);\n    } catch (err) {\n      console.error('Failed to disconnect from global leaderboard channel:', err);\n    }\n  }, []);\n\n  const reconnect = useCallback(async () => {\n    await disconnect();\n    await connect();\n  }, [connect, disconnect]);\n\n  const refreshLeaderboard = useCallback(async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const response = await fetch('/api/leaderboard/global');\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch global leaderboard: ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      setLeaderboard(data.leaderboard || []);\n      setIsLoading(false);\n    } catch (err) {\n      console.error('Failed to refresh global leaderboard:', err);\n      const errorMessage = err instanceof Error ? err.message : 'Failed to refresh global leaderboard';\n      setError(errorMessage);\n      setIsLoading(false);\n      \n      if (onError) {\n        onError(new Error(errorMessage));\n      }\n    }\n  }, [onError]);\n\n  useEffect(() => {\n    connect();\n    return () => {\n      disconnect();\n    };\n  }, []);\n\n  return {\n    leaderboard,\n    isConnected,\n    isLoading,\n    error,\n    reconnect,\n    disconnect,\n    refreshLeaderboard,\n  };\n}"
