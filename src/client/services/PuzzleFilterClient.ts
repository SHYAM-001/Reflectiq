// Client-side service for puzzle filtering and navigation

import type {
  FilterQuery,
  PaginatedResponse,
  PuzzlePost,
  DifficultyLevel,
} from '../../shared/types/index.js';

export class PuzzleFilterClient {
  private baseUrl = '/api/puzzles';

  /**
   * Get filtered puzzles with pagination
   */
  async getFilteredPuzzles(query: FilterQuery): Promise<PaginatedResponse<PuzzlePost>> {
    const params = new URLSearchParams();
    
    if (query.difficulty) params.append('difficulty', query.difficulty);
    if (query.sortBy) params.append('sortBy', query.sortBy);
    if (query.sortOrder) params.append('sortOrder', query.sortOrder);
    if (query.page) params.append('page', query.page.toString());
    if (query.limit) params.append('limit', query.limit.toString());
    if (query.dateFrom) params.append('dateFrom', query.dateFrom.toISOString());
    if (query.dateTo) params.append('dateTo', query.dateTo.toISOString());
    if (query.isActive !== undefined) params.append('isActive', query.isActive.toString());
    if (query.minParticipants) params.append('minParticipants', query.minParticipants.toString());

    const response = await fetch(`${this.baseUrl}/filter?${params}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch filtered puzzles: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    // Convert date strings back to Date objects\n    data.items = data.items.map((puzzle: any) => ({\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    }));\n\n    return data;\n  }\n\n  /**\n   * Search puzzles by text content\n   */\n  async searchPuzzles(searchTerm: string, query: FilterQuery = {}): Promise<PaginatedResponse<PuzzlePost>> {\n    const params = new URLSearchParams();\n    params.append('q', searchTerm);\n    \n    if (query.difficulty) params.append('difficulty', query.difficulty);\n    if (query.sortBy) params.append('sortBy', query.sortBy);\n    if (query.sortOrder) params.append('sortOrder', query.sortOrder);\n    if (query.page) params.append('page', query.page.toString());\n    if (query.limit) params.append('limit', query.limit.toString());\n    if (query.dateFrom) params.append('dateFrom', query.dateFrom.toISOString());\n    if (query.dateTo) params.append('dateTo', query.dateTo.toISOString());\n    if (query.isActive !== undefined) params.append('isActive', query.isActive.toString());\n\n    const response = await fetch(`${this.baseUrl}/search?${params}`);\n    if (!response.ok) {\n      throw new Error(`Failed to search puzzles: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    \n    // Convert date strings back to Date objects\n    data.items = data.items.map((puzzle: any) => ({\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    }));\n\n    return data;\n  }\n\n  /**\n   * Get puzzles by difficulty level\n   */\n  async getPuzzlesByDifficulty(difficulty: DifficultyLevel, limit = 20): Promise<PuzzlePost[]> {\n    const response = await fetch(`${this.baseUrl}/difficulty/${difficulty}?limit=${limit}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch puzzles by difficulty: ${response.statusText}`);\n    }\n\n    const puzzles = await response.json();\n    \n    // Convert date strings back to Date objects\n    return puzzles.map((puzzle: any) => ({\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    }));\n  }\n\n  /**\n   * Get recent puzzles\n   */\n  async getRecentPuzzles(limit = 10): Promise<PuzzlePost[]> {\n    const response = await fetch(`${this.baseUrl}/recent?limit=${limit}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch recent puzzles: ${response.statusText}`);\n    }\n\n    const puzzles = await response.json();\n    \n    // Convert date strings back to Date objects\n    return puzzles.map((puzzle: any) => ({\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    }));\n  }\n\n  /**\n   * Get popular puzzles (by participant count)\n   */\n  async getPopularPuzzles(limit = 10): Promise<PuzzlePost[]> {\n    const response = await fetch(`${this.baseUrl}/popular?limit=${limit}`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch popular puzzles: ${response.statusText}`);\n    }\n\n    const puzzles = await response.json();\n    \n    // Convert date strings back to Date objects\n    return puzzles.map((puzzle: any) => ({\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    }));\n  }\n\n  /**\n   * Get puzzle statistics\n   */\n  async getPuzzleStats(): Promise<{\n    total: number;\n    byDifficulty: Record<DifficultyLevel, number>;\n    totalParticipants: number;\n    averageScore: number;\n  }> {\n    const response = await fetch(`${this.baseUrl}/stats`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch puzzle statistics: ${response.statusText}`);\n    }\n\n    return await response.json();\n  }\n\n  /**\n   * Get puzzle by ID\n   */\n  async getPuzzleById(puzzleId: string): Promise<PuzzlePost> {\n    const response = await fetch(`${this.baseUrl}/${puzzleId}`);\n    if (!response.ok) {\n      if (response.status === 404) {\n        throw new Error('Puzzle not found');\n      }\n      throw new Error(`Failed to fetch puzzle: ${response.statusText}`);\n    }\n\n    const puzzle = await response.json();\n    \n    // Convert date strings back to Date objects\n    return {\n      ...puzzle,\n      createdDate: new Date(puzzle.createdDate),\n    };\n  }\n\n  /**\n   * Update puzzle metadata (admin function)\n   */\n  async updatePuzzleMetadata(puzzleId: string, updates: Partial<{\n    participantCount: number;\n    averageScore: number;\n    isActive: boolean;\n  }>): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/${puzzleId}/metadata`, {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(updates),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to update puzzle metadata: ${response.statusText}`);\n    }\n  }\n\n  /**\n   * Build query parameters for URL navigation\n   */\n  buildQueryParams(query: FilterQuery): string {\n    const params = new URLSearchParams();\n    \n    if (query.difficulty) params.append('difficulty', query.difficulty);\n    if (query.sortBy) params.append('sortBy', query.sortBy);\n    if (query.sortOrder) params.append('sortOrder', query.sortOrder);\n    if (query.page) params.append('page', query.page.toString());\n    if (query.limit) params.append('limit', query.limit.toString());\n    if (query.dateFrom) params.append('dateFrom', query.dateFrom.toISOString().split('T')[0]);\n    if (query.dateTo) params.append('dateTo', query.dateTo.toISOString().split('T')[0]);\n    if (query.isActive !== undefined) params.append('isActive', query.isActive.toString());\n    if (query.minParticipants) params.append('minParticipants', query.minParticipants.toString());\n\n    return params.toString();\n  }\n\n  /**\n   * Parse query parameters from URL\n   */\n  parseQueryParams(searchParams: URLSearchParams): FilterQuery {\n    const query: FilterQuery = {};\n    \n    const difficulty = searchParams.get('difficulty');\n    if (difficulty && ['easy', 'medium', 'hard'].includes(difficulty)) {\n      query.difficulty = difficulty as DifficultyLevel;\n    }\n    \n    const sortBy = searchParams.get('sortBy');\n    if (sortBy && ['date', 'difficulty', 'participants'].includes(sortBy)) {\n      query.sortBy = sortBy as 'date' | 'difficulty' | 'participants';\n    }\n    \n    const sortOrder = searchParams.get('sortOrder');\n    if (sortOrder && ['asc', 'desc'].includes(sortOrder)) {\n      query.sortOrder = sortOrder as 'asc' | 'desc';\n    }\n    \n    const page = searchParams.get('page');\n    if (page) {\n      const pageNum = parseInt(page);\n      if (!isNaN(pageNum) && pageNum > 0) {\n        query.page = pageNum;\n      }\n    }\n    \n    const limit = searchParams.get('limit');\n    if (limit) {\n      const limitNum = parseInt(limit);\n      if (!isNaN(limitNum) && limitNum > 0 && limitNum <= 100) {\n        query.limit = limitNum;\n      }\n    }\n    \n    const dateFrom = searchParams.get('dateFrom');\n    if (dateFrom) {\n      const date = new Date(dateFrom);\n      if (!isNaN(date.getTime())) {\n        query.dateFrom = date;\n      }\n    }\n    \n    const dateTo = searchParams.get('dateTo');\n    if (dateTo) {\n      const date = new Date(dateTo);\n      if (!isNaN(date.getTime())) {\n        query.dateTo = date;\n      }\n    }\n    \n    const isActive = searchParams.get('isActive');\n    if (isActive !== null) {\n      query.isActive = isActive === 'true';\n    }\n    \n    const minParticipants = searchParams.get('minParticipants');\n    if (minParticipants) {\n      const num = parseInt(minParticipants);\n      if (!isNaN(num) && num >= 0) {\n        query.minParticipants = num;\n      }\n    }\n    \n    return query;\n  }\n}\n\n// Export singleton instance\nexport const puzzleFilterClient = new PuzzleFilterClient();"
